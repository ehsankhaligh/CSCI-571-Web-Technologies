{"ast":null,"code":"/*\n Highstock JS v10.0.0 (2022-03-07)\n\n Indicator series type for Highcharts Stock\n\n (c) 2010-2021 Pawel Fus, Sebastian Bochan\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/indicators/indicators\", [\"highcharts\", \"highcharts/modules/stock\"], function (k) {\n    a(k);\n    a.Highcharts = k;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function k(a, g, e, k) {\n    a.hasOwnProperty(g) || (a[g] = k.apply(null, e), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: g,\n        module: a[g]\n      }\n    })));\n  }\n\n  a = a ? a._modules : {};\n  k(a, \"Stock/Indicators/SMA/SMAComposition.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, g) {});\n  k(a, \"Stock/Indicators/SMA/SMAIndicator.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, g, e) {\n    var k = this && this.__extends || function () {\n      var a = function (h, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var c in d) d.hasOwnProperty(c) && (b[c] = d[c]);\n        };\n\n        return a(h, b);\n      };\n\n      return function (h, b) {\n        function c() {\n          this.constructor = h;\n        }\n\n        a(h, b);\n        h.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());\n      };\n    }(),\n        n = g.seriesTypes.line,\n        p = e.addEvent,\n        t = e.error,\n        u = e.extend,\n        v = e.isArray,\n        h = e.merge,\n        f = e.pick,\n        q = e.splat;\n\n    e = function (m) {\n      function l() {\n        var b = null !== m && m.apply(this, arguments) || this;\n        b.data = void 0;\n        b.dataEventsToUnbind = void 0;\n        b.linkedParent = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      k(l, m);\n\n      l.prototype.destroy = function () {\n        this.dataEventsToUnbind.forEach(function (b) {\n          b();\n        });\n        m.prototype.destroy.apply(this, arguments);\n      };\n\n      l.prototype.getName = function () {\n        var b = this.name,\n            c = [];\n        b || ((this.nameComponents || []).forEach(function (b, a) {\n          c.push(this.options.params[b] + f(this.nameSuffixes[a], \"\"));\n        }, this), b = (this.nameBase || this.type.toUpperCase()) + (this.nameComponents ? \" (\" + c.join(\", \") + \")\" : \"\"));\n        return b;\n      };\n\n      l.prototype.getValues = function (b, c) {\n        var d = c.period,\n            a = b.xData;\n        b = b.yData;\n        var h = b.length,\n            f = 0,\n            q = 0,\n            l = [],\n            m = [],\n            g = [],\n            e = -1;\n\n        if (!(a.length < d)) {\n          for (v(b[0]) && (e = c.index ? c.index : 0); f < d - 1;) q += 0 > e ? b[f] : b[f][e], f++;\n\n          for (c = f; c < h; c++) {\n            q += 0 > e ? b[c] : b[c][e];\n            var k = [a[c], q / d];\n            l.push(k);\n            m.push(k[0]);\n            g.push(k[1]);\n            q -= 0 > e ? b[c - f] : b[c - f][e];\n          }\n\n          return {\n            values: l,\n            xData: m,\n            yData: g\n          };\n        }\n      };\n\n      l.prototype.init = function (b, c) {\n        var d = this;\n        m.prototype.init.call(d, b, c);\n        c = p(a, \"afterLinkSeries\", function () {\n          var c = !!d.dataEventsToUnbind.length;\n          if (d.linkedParent) {\n            if (c || (d.dataEventsToUnbind.push(p(d.linkedParent, \"updatedData\", function () {\n              d.recalculateValues();\n            })), d.calculateOn.xAxis && d.dataEventsToUnbind.push(p(d.linkedParent.xAxis, d.calculateOn.xAxis, function () {\n              d.recalculateValues();\n            }))), \"init\" === d.calculateOn.chart) d.processedYData || d.recalculateValues();else {\n              if (!c) var a = p(d.chart, d.calculateOn.chart, function () {\n                d.recalculateValues();\n                a();\n              });\n            }\n          } else return t(\"Series \" + d.options.linkedTo + \" not found! Check `linkedTo`.\", !1, b);\n        }, {\n          order: 0\n        });\n        d.dataEventsToUnbind = [];\n        d.eventsToUnbind.push(c);\n      };\n\n      l.prototype.recalculateValues = function () {\n        var b = this.points || [],\n            c = (this.xData || []).length,\n            d = {\n          values: [],\n          xData: [],\n          yData: []\n        },\n            a = [],\n            h = !0;\n        d = this.linkedParent.options ? this.getValues(this.linkedParent, this.options.params) || d : d;\n        if (c && !this.hasGroupedData && this.visible && this.points) if (this.cropped) {\n          if (this.xAxis) {\n            var f = this.xAxis.min;\n            var e = this.xAxis.max;\n          }\n\n          c = this.cropData(d.xData, d.yData, f, e);\n\n          for (f = 0; f < c.xData.length; f++) a.push([c.xData[f]].concat(q(c.yData[f])));\n\n          c = d.xData.indexOf(this.xData[0]);\n          f = d.xData.indexOf(this.xData[this.xData.length - 1]);\n          -1 === c && f === d.xData.length - 2 && a[0][0] === b[0].x && a.shift();\n          this.updateData(a);\n        } else d.xData.length !== c - 1 && d.xData.length !== c + 1 && (h = !1, this.updateData(d.values));\n        h && (this.xData = d.xData, this.yData = d.yData, this.options.data = d.values);\n        this.calculateOn.xAxis && this.processedXData && (delete this.processedXData, this.isDirty = !0, this.redraw());\n        this.isDirtyData = !1;\n      };\n\n      l.prototype.processData = function () {\n        var b = this.options.compareToMain,\n            c = this.linkedParent;\n        m.prototype.processData.apply(this, arguments);\n        this.dataModify && c && c.dataModify && c.dataModify.compareValue && b && (this.dataModify.compareValue = c.dataModify.compareValue);\n      };\n\n      l.defaultOptions = h(n.defaultOptions, {\n        name: void 0,\n        tooltip: {\n          valueDecimals: 4\n        },\n        linkedTo: void 0,\n        compareToMain: !1,\n        params: {\n          index: 3,\n          period: 14\n        }\n      });\n      return l;\n    }(n);\n\n    u(e.prototype, {\n      calculateOn: {\n        chart: \"init\"\n      },\n      hasDerivedData: !0,\n      nameComponents: [\"period\"],\n      nameSuffixes: [],\n      useCommonDataGrouping: !0\n    });\n    g.registerSeriesType(\"sma\", e);\n    \"\";\n    return e;\n  });\n  k(a, \"Stock/Indicators/EMA/EMAIndicator.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, g) {\n    var e = this && this.__extends || function () {\n      var a = function (e, h) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, h) {\n          a.__proto__ = h;\n        } || function (a, h) {\n          for (var f in h) h.hasOwnProperty(f) && (a[f] = h[f]);\n        };\n\n        return a(e, h);\n      };\n\n      return function (e, h) {\n        function f() {\n          this.constructor = e;\n        }\n\n        a(e, h);\n        e.prototype = null === h ? Object.create(h) : (f.prototype = h.prototype, new f());\n      };\n    }(),\n        k = a.seriesTypes.sma,\n        n = g.correctFloat,\n        p = g.isArray,\n        t = g.merge;\n\n    g = function (a) {\n      function g() {\n        var h = null !== a && a.apply(this, arguments) || this;\n        h.data = void 0;\n        h.options = void 0;\n        h.points = void 0;\n        return h;\n      }\n\n      e(g, a);\n\n      g.prototype.accumulatePeriodPoints = function (a, f, e) {\n        for (var h = 0, g = 0, b; g < a;) b = 0 > f ? e[g] : e[g][f], h += b, g++;\n\n        return h;\n      };\n\n      g.prototype.calculateEma = function (a, f, e, g, k, b, c) {\n        a = a[e - 1];\n        f = 0 > b ? f[e - 1] : f[e - 1][b];\n        g = \"undefined\" === typeof k ? c : n(f * g + k * (1 - g));\n        return [a, g];\n      };\n\n      g.prototype.getValues = function (a, f) {\n        var e = f.period,\n            g = a.xData,\n            h = (a = a.yData) ? a.length : 0,\n            b = 2 / (e + 1),\n            c = [],\n            d = [],\n            k = [],\n            n = -1;\n\n        if (!(h < e)) {\n          p(a[0]) && (n = f.index ? f.index : 0);\n          f = this.accumulatePeriodPoints(e, n, a);\n\n          for (f /= e; e < h + 1; e++) {\n            var r = this.calculateEma(g, a, e, b, r, n, f);\n            c.push(r);\n            d.push(r[0]);\n            k.push(r[1]);\n            r = r[1];\n          }\n\n          return {\n            values: c,\n            xData: d,\n            yData: k\n          };\n        }\n      };\n\n      g.defaultOptions = t(k.defaultOptions, {\n        params: {\n          index: 3,\n          period: 9\n        }\n      });\n      return g;\n    }(k);\n\n    a.registerSeriesType(\"ema\", g);\n    \"\";\n    return g;\n  });\n  k(a, \"masters/indicators/indicators.src.js\", [], function () {});\n}); //# sourceMappingURL=indicators.js.map","map":null,"metadata":{},"sourceType":"script"}