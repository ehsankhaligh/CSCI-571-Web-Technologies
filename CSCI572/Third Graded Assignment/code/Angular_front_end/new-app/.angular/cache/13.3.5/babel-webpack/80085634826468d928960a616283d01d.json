{"ast":null,"code":"/*\n Highstock JS v10.0.0 (2022-03-07)\n\n Highcharts Stock as a plugin for Highcharts\n\n (c) 2010-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/stock\", [\"highcharts\"], function (L) {\n    a(L);\n    a.Highcharts = L;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function L(a, r, y, t) {\n    a.hasOwnProperty(r) || (a[r] = t.apply(null, y), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: r,\n        module: a[r]\n      }\n    })));\n  }\n\n  a = a ? a._modules : {};\n  L(a, \"Core/Axis/OrdinalAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t) {\n    var l = t.addEvent,\n        D = t.correctFloat,\n        E = t.css,\n        x = t.defined,\n        b = t.error,\n        m = t.pick,\n        d = t.timeUnits,\n        z = [],\n        h;\n\n    (function (h) {\n      function G(f, e, c, p, n, g, u) {\n        void 0 === n && (n = []);\n        void 0 === g && (g = 0);\n        var w = {},\n            Q = this.options.tickPixelInterval,\n            N = this.chart.time,\n            B = [],\n            H,\n            A,\n            k = 0,\n            v = [],\n            h = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !n || 3 > n.length || \"undefined\" === typeof e) return N.getTimeTicks.apply(N, arguments);\n        var m = n.length;\n\n        for (H = 0; H < m; H++) {\n          var F = H && n[H - 1] > c;\n          n[H] < e && (k = H);\n\n          if (H === m - 1 || n[H + 1] - n[H] > 5 * g || F) {\n            if (n[H] > h) {\n              for (A = N.getTimeTicks(f, n[k], n[H], p); A.length && A[0] <= h;) A.shift();\n\n              A.length && (h = A[A.length - 1]);\n              B.push(v.length);\n              v = v.concat(A);\n            }\n\n            k = H + 1;\n          }\n\n          if (F) break;\n        }\n\n        if (A) {\n          A = A.info;\n\n          if (u && A.unitRange <= d.hour) {\n            H = v.length - 1;\n\n            for (k = 1; k < H; k++) if (N.dateFormat(\"%d\", v[k]) !== N.dateFormat(\"%d\", v[k - 1])) {\n              w[v[k]] = \"day\";\n              var q = !0;\n            }\n\n            q && (w[v[0]] = \"day\");\n            A.higherRanks = w;\n          }\n\n          A.segmentStarts = B;\n          v.info = A;\n        } else b(12, !1, this.chart);\n\n        if (u && x(Q)) {\n          A = v.length;\n          N = [];\n          k = [];\n          H = void 0;\n\n          for (q = A; q--;) B = this.translate(v[q]), H && (k[q] = H - B), N[q] = H = B;\n\n          k.sort();\n          k = k[Math.floor(k.length / 2)];\n          k < .6 * Q && (k = null);\n          q = v[A - 1] > c ? A - 1 : A;\n\n          for (H = void 0; q--;) B = N[q], A = Math.abs(H - B), H && A < .8 * Q && (null === k || A < .8 * k) ? (w[v[q]] && !w[v[q + 1]] ? (A = q + 1, H = B) : A = q, v.splice(A, 1)) : H = B;\n        }\n\n        return v;\n      }\n\n      function J(f) {\n        var e = this.ordinal.positions;\n        if (!e) return f;\n        var c = e.length - 1;\n        if (0 > f) f = e[0];else if (f > c) f = e[c];else {\n          c = Math.floor(f);\n          var p = f - c;\n        }\n        return \"undefined\" !== typeof p && \"undefined\" !== typeof e[c] ? e[c] + (p ? p * (e[c + 1] - e[c]) : 0) : f;\n      }\n\n      function C(f) {\n        var e = this.ordinal,\n            c = e.positions;\n        if (!c) return f;\n        var p = (f - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;\n        0 < p && p < this.left + this.len || (e.extendedOrdinalPositions || (e.extendedOrdinalPositions = e.getExtendedPositions()), c = e.extendedOrdinalPositions);\n\n        if (c && c.length) {\n          f = e.getIndexOfPoint(p, c);\n          e = D(f % 1);\n          if (0 <= f && f < c.length - 1) return c[Math.floor(f)] + e * (c[Math.ceil(f)] - c[Math.floor(f)]);\n          e = c.length;\n          p = c[0];\n          c = c[e - 1];\n          var n = (c - p) / (e - 1);\n          return 0 > f ? p + n * f : c + n * (f - e);\n        }\n\n        return f;\n      }\n\n      function q(f, e) {\n        var c = h.Additions.findIndexOf(f, e, !0);\n        return f[c] === e ? c : c + (e - f[c]) / (f[c + 1] - f[c]);\n      }\n\n      function K() {\n        this.ordinal || (this.ordinal = new h.Additions(this));\n      }\n\n      function a() {\n        this.isXAxis && x(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && x(this.userMin) && (this.min += this.options.overscroll));\n      }\n\n      function F() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n\n      function M() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n\n      function v(f) {\n        var e = this.xAxis[0],\n            c = e.options.overscroll,\n            p = f.originalEvent.chartX,\n            n = this.options.chart.panning,\n            g = !1;\n\n        if (n && \"y\" !== n.type && e.options.ordinal && e.series.length) {\n          var u = this.mouseDownX,\n              w = e.getExtremes(),\n              Q = w.dataMax,\n              N = w.min,\n              B = w.max,\n              H = this.hoverPoints,\n              A = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange;\n          u = (u - p) / (e.translationSlope * (e.ordinal.slope || A));\n          A = {\n            ordinal: {\n              positions: e.ordinal.getExtendedPositions()\n            }\n          };\n          var k = e.index2val,\n              v = e.val2lin,\n              d = void 0,\n              h = d = void 0,\n              q = void 0;\n          A.ordinal.positions ? 1 < Math.abs(u) && (H && H.forEach(function (g) {\n            g.setState();\n          }), 0 > u ? (h = A, q = e.ordinal.positions ? e : A) : (h = e.ordinal.positions ? e : A, q = A), d = q.ordinal.positions, Q > d[d.length - 1] && d.push(Q), this.fixedRange = B - N, d = e.navigatorAxis.toFixedRange(void 0, void 0, k.apply(h, [v.apply(h, [N, !0]) + u]), k.apply(q, [v.apply(q, [B, !0]) + u])), d.min >= Math.min(w.dataMin, N) && d.max <= Math.max(Q, B) + c && e.setExtremes(d.min, d.max, !0, !1, {\n            trigger: \"pan\"\n          }), this.mouseDownX = p, E(this.container, {\n            cursor: \"move\"\n          })) : g = !0;\n        } else g = !0;\n\n        g || n && /y/.test(n.type) ? c && (e.max = e.dataMax + c) : f.preventDefault();\n      }\n\n      function P() {\n        var f = this.xAxis;\n        f && f.options.ordinal && (delete f.ordinal.index, delete f.ordinal.extendedOrdinalPositions);\n      }\n\n      function k(f, e) {\n        var c = this.ordinal,\n            p = c.positions,\n            n = c.slope,\n            g = c.extendedOrdinalPositions;\n        if (!p) return f;\n        var u = p.length;\n        if (p[0] <= f && p[u - 1] >= f) f = q(p, f);else {\n          g || (g = c.getExtendedPositions && c.getExtendedPositions(), c.extendedOrdinalPositions = g);\n          if (!g || !g.length) return f;\n          u = g.length;\n          n || (n = (g[u - 1] - g[0]) / u);\n          p = q(g, p[0]);\n          f >= g[0] && f <= g[u - 1] ? f = q(g, f) - p : f < g[0] ? (f = g[0] - f, f = -p - f / n) : (f -= g[u - 1], f = f / n + u - p);\n        }\n        return e ? f : n * (f || 0) + c.offset;\n      }\n\n      h.compose = function (f, e, c) {\n        if (-1 === z.indexOf(f)) {\n          z.push(f);\n          var p = f.prototype;\n          p.getTimeTicks = G;\n          p.index2val = J;\n          p.lin2val = C;\n          p.val2lin = k;\n          p.ordinal2lin = p.val2lin;\n          l(f, \"afterInit\", K);\n          l(f, \"foundExtremes\", a);\n          l(f, \"afterSetScale\", F);\n          l(f, \"initialAxisTranslation\", M);\n        }\n\n        -1 === z.indexOf(c) && (z.push(c), l(c, \"pan\", v));\n        -1 === z.indexOf(e) && (z.push(e), l(e, \"updatedData\", P));\n        return f;\n      };\n\n      var I = function () {\n        function f(e) {\n          this.index = {};\n          this.axis = e;\n        }\n\n        f.prototype.beforeSetTickPositions = function () {\n          var e = this.axis,\n              c = e.ordinal,\n              p = e.getExtremes(),\n              n = p.min,\n              g = p.max,\n              u = e.isXAxis && !!e.options.breaks;\n          p = e.options.ordinal;\n          var w = e.chart.options.chart.ignoreHiddenSeries,\n              f,\n              N,\n              B = [],\n              H = Number.MAX_VALUE,\n              A = !1;\n\n          if (p || u) {\n            e.series.forEach(function (g, c) {\n              f = [];\n\n              if (!(w && !1 === g.visible || !1 === g.takeOrdinalPosition && !u) && (B = B.concat(g.processedXData), k = B.length, B.sort(function (g, c) {\n                return g - c;\n              }), H = Math.min(H, m(g.closestPointRange, H)), k)) {\n                for (c = 0; c < k - 1;) B[c] !== B[c + 1] && f.push(B[c + 1]), c++;\n\n                f[0] !== B[0] && f.unshift(B[0]);\n                B = f;\n              }\n            });\n            var k = B.length;\n\n            if (2 < k) {\n              var d = B[1] - B[0];\n\n              for (N = k - 1; N-- && !A;) B[N + 1] - B[N] !== d && (A = !0);\n\n              !e.options.keepOrdinalPadding && (B[0] - n > d || g - B[B.length - 1] > d) && (A = !0);\n            } else e.options.overscroll && (2 === k ? H = B[1] - B[0] : 1 === k ? (H = e.options.overscroll, B = [B[0], B[0] + H]) : H = c.overscrollPointsRange);\n\n            A || e.forceOrdinal ? (e.options.overscroll && (c.overscrollPointsRange = H, B = B.concat(c.getOverscrollPositions())), c.positions = B, d = e.ordinal2lin(Math.max(n, B[0]), !0), N = Math.max(e.ordinal2lin(Math.min(g, B[B.length - 1]), !0), 1), c.slope = g = (g - n) / (N - d), c.offset = n - d * g) : (c.overscrollPointsRange = m(e.closestPointRange, c.overscrollPointsRange), c.positions = e.ordinal.slope = c.offset = void 0);\n          }\n\n          e.isOrdinal = p && A;\n          c.groupIntervalFactor = null;\n        };\n\n        f.findIndexOf = function (e, c, p) {\n          for (var n = 0, g = e.length - 1, u; n < g;) u = Math.ceil((n + g) / 2), e[u] <= c ? n = u : g = u - 1;\n\n          return e[n] === c ? n : p ? n : -1;\n        };\n\n        f.prototype.getExtendedPositions = function () {\n          var e = this,\n              c = e.axis,\n              p = c.constructor.prototype,\n              n = c.chart,\n              g = c.series[0].currentDataGrouping,\n              u = g ? g.count + g.unitName : \"raw\",\n              w = c.options.overscroll,\n              f = c.getExtremes(),\n              k = void 0,\n              B = e.index;\n          B || (B = e.index = {});\n\n          if (!B[u]) {\n            var H = {\n              series: [],\n              chart: n,\n              forceOrdinal: !1,\n              getExtremes: function () {\n                return {\n                  min: f.dataMin,\n                  max: f.dataMax + w\n                };\n              },\n              getGroupPixelWidth: p.getGroupPixelWidth,\n              getTimeTicks: p.getTimeTicks,\n              options: {\n                ordinal: !0\n              },\n              ordinal: {\n                getGroupIntervalFactor: this.getGroupIntervalFactor\n              },\n              ordinal2lin: p.ordinal2lin,\n              getIndexOfPoint: p.getIndexOfPoint,\n              val2lin: p.val2lin\n            };\n            H.ordinal.axis = H;\n            c.series.forEach(function (c) {\n              k = {\n                xAxis: H,\n                xData: c.xData.slice(),\n                chart: n,\n                destroyGroupedData: r.noop,\n                getProcessedData: y.prototype.getProcessedData,\n                applyGrouping: y.prototype.applyGrouping\n              };\n              k.xData = k.xData.concat(e.getOverscrollPositions());\n              k.options = {\n                dataGrouping: g ? {\n                  firstAnchor: \"firstPoint\",\n                  anchor: \"middle\",\n                  lastAnchor: \"lastPoint\",\n                  enabled: !0,\n                  forced: !0,\n                  approximation: \"open\",\n                  units: [[g.unitName, [g.count]]]\n                } : {\n                  enabled: !1\n                }\n              };\n              H.series.push(k);\n              c.processData.apply(k);\n            });\n            k.closestPointRange !== k.basePointRange && k.currentDataGrouping && (H.forceOrdinal = !0);\n            c.ordinal.beforeSetTickPositions.apply({\n              axis: H\n            });\n            B[u] = H.ordinal.positions;\n          }\n\n          return B[u];\n        };\n\n        f.prototype.getGroupIntervalFactor = function (e, c, p) {\n          p = p.processedXData;\n          var n = p.length,\n              g = [];\n          var u = this.groupIntervalFactor;\n\n          if (!u) {\n            for (u = 0; u < n - 1; u++) g[u] = p[u + 1] - p[u];\n\n            g.sort(function (g, c) {\n              return g - c;\n            });\n            g = g[Math.floor(n / 2)];\n            e = Math.max(e, p[0]);\n            c = Math.min(c, p[n - 1]);\n            this.groupIntervalFactor = u = n * g / (c - e);\n          }\n\n          return u;\n        };\n\n        f.prototype.getIndexOfPoint = function (e, c) {\n          var p = this.axis,\n              n = this.positions ? this.positions[0] : 0,\n              g = p.series[0].points && p.series[0].points[0] && p.series[0].points[0].plotX || p.minPixelPadding;\n          1 < p.series.length && p.series.forEach(function (c) {\n            c.points && x(c.points[0]) && x(c.points[0].plotX) && c.points[0].plotX < g && (g = c.points[0].plotX);\n          });\n          e = (e - g) / (p.translationSlope * (this.slope || p.closestPointRange || this.overscrollPointsRange));\n          return f.findIndexOf(c, n) + e;\n        };\n\n        f.prototype.getOverscrollPositions = function () {\n          var e = this.axis,\n              c = e.options.overscroll,\n              p = this.overscrollPointsRange,\n              n = [],\n              g = e.dataMax;\n          if (x(p)) for (; g <= e.dataMax + c;) g += p, n.push(g);\n          return n;\n        };\n\n        f.prototype.postProcessTickInterval = function (e) {\n          var c = this.axis,\n              p = this.slope;\n          return p ? c.options.breaks ? c.closestPointRange || e : e / (p / c.closestPointRange) : e;\n        };\n\n        return f;\n      }();\n\n      h.Additions = I;\n    })(h || (h = {}));\n\n    return h;\n  });\n  L(a, \"Series/DataModifyComposition.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t) {\n    var l = r.prototype.tooltipFormatter,\n        D = t.addEvent,\n        E = t.arrayMax,\n        x = t.arrayMin,\n        b = t.correctFloat,\n        m = t.defined,\n        d = t.isArray,\n        z = t.isNumber,\n        h = t.isString,\n        K = t.pick,\n        G;\n\n    (function (J) {\n      function C(e, c, p) {\n        this.isXAxis || (this.series.forEach(function (n) {\n          \"compare\" === e && \"boolean\" !== typeof c ? n.setCompare(c, !1) : \"cumulative\" !== e || h(c) || n.setCumulative(c, !1);\n        }), K(p, !0) && this.chart.redraw());\n      }\n\n      function q(e) {\n        var c = this,\n            p = c.series.chart.numberFormatter,\n            n = function (g) {\n          e = e.replace(\"{point.\" + g + \"}\", (0 < c[g] && \"change\" === g ? \"+\" : \"\") + p(c[g], K(c.series.tooltipOptions.changeDecimals, 2)));\n        };\n\n        m(c.change) && n(\"change\");\n        m(c.cumulativeSum) && n(\"cumulativeSum\");\n        return l.apply(this, [e]);\n      }\n\n      function a() {\n        var e = this.options.compare;\n\n        if (\"percent\" === e || \"value\" === e || this.options.cumulative) {\n          var c = new f(this);\n          \"percent\" === e || \"value\" === e ? c.initCompare(e) : c.initCumulative();\n        }\n\n        this.dataModify = c;\n      }\n\n      function G(e) {\n        e = e.dataExtremes;\n        var c = e.activeYData;\n\n        if (this.dataModify && e) {\n          var p = void 0;\n          this.options.compare ? p = [this.dataModify.modifyValue(e.dataMin), this.dataModify.modifyValue(e.dataMax)] : this.options.cumulative && d(c) && 2 <= c.length && (p = f.getCumulativeExtremes(c));\n          p && (e.dataMin = x(p), e.dataMax = E(p));\n        }\n      }\n\n      function F(e, c) {\n        this.options.compare = this.userOptions.compare = e;\n        this.update({}, K(c, !0));\n        !this.dataModify || \"value\" !== e && \"percent\" !== e ? this.points.forEach(function (c) {\n          delete c.change;\n        }) : this.dataModify.initCompare(e);\n      }\n\n      function M() {\n        if (this.xAxis && this.processedYData && this.dataModify) {\n          var e = this.processedXData,\n              c = this.processedYData,\n              p = c.length,\n              n = !0 === this.options.compareStart ? 0 : 1,\n              g = -1,\n              u;\n          this.pointArrayMap && (g = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\"));\n\n          for (u = 0; u < p - n; u++) {\n            var w = c[u] && -1 < g ? c[u][g] : c[u];\n\n            if (z(w) && 0 !== w && e[u + n] >= (this.xAxis.min || 0)) {\n              this.dataModify.compareValue = w;\n              break;\n            }\n          }\n        }\n      }\n\n      function v(e, c) {\n        this.setModifier(\"compare\", e, c);\n      }\n\n      function P(e, c) {\n        e = K(e, !1);\n        this.options.cumulative = this.userOptions.cumulative = e;\n        this.update({}, K(c, !0));\n        this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(function (c) {\n          delete c.cumulativeSum;\n        });\n      }\n\n      function k(e, c) {\n        this.setModifier(\"cumulative\", e, c);\n      }\n\n      var I = [];\n\n      J.compose = function (e, c, p) {\n        if (-1 === I.indexOf(e)) {\n          I.push(e);\n          var n = e.prototype;\n          n.setCompare = F;\n          n.setCumulative = P;\n          D(e, \"afterInit\", a);\n          D(e, \"afterGetExtremes\", G);\n          D(e, \"afterProcessData\", M);\n        }\n\n        -1 === I.indexOf(c) && (I.push(c), c = c.prototype, c.setCompare = v, c.setModifier = C, c.setCumulative = k);\n        -1 === I.indexOf(p) && (I.push(p), p.prototype.tooltipFormatter = q);\n        return e;\n      };\n\n      var f = function () {\n        function e(c) {\n          this.series = c;\n        }\n\n        e.prototype.modifyValue = function () {\n          return 0;\n        };\n\n        e.getCumulativeExtremes = function (c) {\n          var e = Infinity,\n              n = -Infinity;\n          c.reduce(function (g, c) {\n            c = g + c;\n            e = Math.min(e, c, g);\n            n = Math.max(n, c, g);\n            return c;\n          });\n          return [e, n];\n        };\n\n        e.prototype.initCompare = function (c) {\n          this.modifyValue = function (e, n) {\n            null === e && (e = 0);\n            var g = this.compareValue;\n            return \"undefined\" !== typeof e && \"undefined\" !== typeof g ? (e = \"value\" === c ? e - g : e / g * 100 - (100 === this.series.options.compareBase ? 0 : 100), \"undefined\" !== typeof n && (n = this.series.points[n]) && (n.change = e), e) : 0;\n          };\n        };\n\n        e.prototype.initCumulative = function () {\n          this.modifyValue = function (c, e) {\n            null === c && (c = 0);\n\n            if (void 0 !== c && void 0 !== e) {\n              var n = 0 < e ? this.series.points[e - 1] : null;\n              n && n.cumulativeSum && (c = b(n.cumulativeSum + c));\n              if (e = this.series.points[e]) e.cumulativeSum = c;\n              return c;\n            }\n\n            return 0;\n          };\n        };\n\n        return e;\n      }();\n\n      J.Additions = f;\n    })(G || (G = {}));\n\n    \"\";\n    return G;\n  });\n  L(a, \"Core/Axis/BrokenAxis.js\", [a[\"Extensions/Stacking.js\"], a[\"Core/Utilities.js\"]], function (a, r) {\n    var y = r.addEvent,\n        t = r.find,\n        l = r.fireEvent,\n        D = r.isArray,\n        E = r.isNumber,\n        x = r.pick,\n        b;\n\n    (function (m) {\n      function d() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n\n      function b() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n\n      function h() {\n        var d = this.brokenAxis;\n\n        if (d && d.hasBreaks) {\n          for (var q = this.tickPositions, v = this.tickPositions.info, h = [], k = 0; k < q.length; k++) d.isInAnyBreak(q[k]) || h.push(q[k]);\n\n          this.tickPositions = h;\n          this.tickPositions.info = v;\n        }\n      }\n\n      function K() {\n        this.brokenAxis || (this.brokenAxis = new S(this));\n      }\n\n      function G() {\n        var d = this.options.connectNulls,\n            q = this.points,\n            v = this.xAxis,\n            h = this.yAxis;\n        if (this.isDirty) for (var k = q.length; k--;) {\n          var b = q[k],\n              f = !(null === b.y && !1 === d) && (v && v.brokenAxis && v.brokenAxis.isInAnyBreak(b.x, !0) || h && h.brokenAxis && h.brokenAxis.isInAnyBreak(b.y, !0));\n          b.visible = f ? !1 : !1 !== b.options.visible;\n        }\n      }\n\n      function J() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, x(this.pointArrayMap, [\"y\"]));\n      }\n\n      function C(d, q) {\n        var v = this,\n            h = v.points,\n            k,\n            b,\n            f,\n            e;\n\n        if (d && d.brokenAxis && d.brokenAxis.hasBreaks) {\n          var c = d.brokenAxis;\n          q.forEach(function (p) {\n            k = c && c.breakArray || [];\n            b = d.isXAxis ? d.min : x(v.options.threshold, d.min);\n            h.forEach(function (c) {\n              e = x(c[\"stack\" + p.toUpperCase()], c[p]);\n              k.forEach(function (g) {\n                if (E(b) && E(e)) {\n                  f = !1;\n                  if (b < g.from && e > g.to || b > g.from && e < g.from) f = \"pointBreak\";else if (b < g.from && e > g.from && e < g.to || b > g.from && e > g.to && e < g.from) f = \"pointInBreak\";\n                  f && l(d, f, {\n                    point: c,\n                    brk: g\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n\n      function q() {\n        var d = this.currentDataGrouping,\n            q = d && d.gapSize;\n        d = this.points.slice();\n        var v = this.yAxis,\n            h = this.options.gapSize,\n            k = d.length - 1,\n            b;\n        if (h && 0 < k) for (\"value\" !== this.options.gapUnit && (h *= this.basePointRange), q && q > h && q >= this.basePointRange && (h = q), b = void 0; k--;) b && !1 !== b.visible || (b = d[k + 1]), q = d[k], !1 !== b.visible && !1 !== q.visible && (b.x - q.x > h && (b = (q.x + b.x) / 2, d.splice(k + 1, 0, {\n          isNull: !0,\n          x: b\n        }), v.stacking && this.options.stacking && (b = v.stacking.stacks[this.stackKey][b] = new a(v, v.options.stackLabels, !1, b, this.stack), b.total = 0)), b = q);\n        return this.getGraphPath(d);\n      }\n\n      var R = [];\n\n      m.compose = function (m, a) {\n        -1 === R.indexOf(m) && (R.push(m), m.keepProps.push(\"brokenAxis\"), y(m, \"init\", K), y(m, \"afterInit\", d), y(m, \"afterSetTickPositions\", h), y(m, \"afterSetOptions\", b));\n\n        if (-1 === R.indexOf(a)) {\n          R.push(a);\n          var v = a.prototype;\n          v.drawBreaks = C;\n          v.gappedPath = q;\n          y(a, \"afterGeneratePoints\", G);\n          y(a, \"afterRender\", J);\n        }\n\n        return m;\n      };\n\n      var S = function () {\n        function d(d) {\n          this.hasBreaks = !1;\n          this.axis = d;\n        }\n\n        d.isInBreak = function (d, b) {\n          var q = d.repeat || Infinity,\n              k = d.from,\n              h = d.to - d.from;\n          b = b >= k ? (b - k) % q : q - (k - b) % q;\n          return d.inclusive ? b <= h : b < h && 0 !== b;\n        };\n\n        d.lin2Val = function (b) {\n          var q = this.brokenAxis;\n          q = q && q.breakArray;\n          if (!q || !E(b)) return b;\n          var h;\n\n          for (h = 0; h < q.length; h++) {\n            var k = q[h];\n            if (k.from >= b) break;else k.to < b ? b += k.len : d.isInBreak(k, b) && (b += k.len);\n          }\n\n          return b;\n        };\n\n        d.val2Lin = function (b) {\n          var q = this.brokenAxis;\n          q = q && q.breakArray;\n          if (!q || !E(b)) return b;\n          var h = b,\n              k;\n\n          for (k = 0; k < q.length; k++) {\n            var m = q[k];\n            if (m.to <= b) h -= m.len;else if (m.from >= b) break;else if (d.isInBreak(m, b)) {\n              h -= b - m.from;\n              break;\n            }\n          }\n\n          return h;\n        };\n\n        d.prototype.findBreakAt = function (d, b) {\n          return t(b, function (b) {\n            return b.from < d && d < b.to;\n          });\n        };\n\n        d.prototype.isInAnyBreak = function (b, q) {\n          var h = this.axis,\n              k = h.options.breaks || [],\n              m = k.length,\n              f;\n\n          if (m && E(b)) {\n            for (; m--;) if (d.isInBreak(k[m], b)) {\n              var e = !0;\n              f || (f = x(k[m].showPoints, !h.isXAxis));\n            }\n\n            var c = e && q ? e && !f : e;\n          }\n\n          return c;\n        };\n\n        d.prototype.setBreaks = function (b, q) {\n          var h = this,\n              k = h.axis,\n              m = D(b) && !!b.length;\n          k.isDirty = h.hasBreaks !== m;\n          h.hasBreaks = m;\n          k.options.breaks = k.userOptions.breaks = b;\n          k.forceRedraw = !0;\n          k.series.forEach(function (f) {\n            f.isDirty = !0;\n          });\n          m || k.val2lin !== d.val2Lin || (delete k.val2lin, delete k.lin2val);\n          m && (k.userOptions.ordinal = !1, k.lin2val = d.lin2Val, k.val2lin = d.val2Lin, k.setExtremes = function (f, e, c, p, n) {\n            if (h.hasBreaks) {\n              for (var g = this.options.breaks || [], u; u = h.findBreakAt(f, g);) f = u.to;\n\n              for (; u = h.findBreakAt(e, g);) e = u.from;\n\n              e < f && (e = f);\n            }\n\n            k.constructor.prototype.setExtremes.call(this, f, e, c, p, n);\n          }, k.setAxisTranslation = function () {\n            k.constructor.prototype.setAxisTranslation.call(this);\n            h.unitLength = void 0;\n\n            if (h.hasBreaks) {\n              var f = k.options.breaks || [],\n                  e = [],\n                  c = [],\n                  p = x(k.pointRangePadding, 0),\n                  n = 0,\n                  g,\n                  u = k.userMin || k.min,\n                  w = k.userMax || k.max,\n                  b;\n              f.forEach(function (c) {\n                g = c.repeat || Infinity;\n                E(u) && E(w) && (d.isInBreak(c, u) && (u += c.to % g - u % g), d.isInBreak(c, w) && (w -= w % g - c.from % g));\n              });\n              f.forEach(function (c) {\n                B = c.from;\n                g = c.repeat || Infinity;\n\n                if (E(u) && E(w)) {\n                  for (; B - g > u;) B -= g;\n\n                  for (; B < u;) B += g;\n\n                  for (b = B; b < w; b += g) e.push({\n                    value: b,\n                    move: \"in\"\n                  }), e.push({\n                    value: b + c.to - c.from,\n                    move: \"out\",\n                    size: c.breakSize\n                  });\n                }\n              });\n              e.sort(function (g, c) {\n                return g.value === c.value ? (\"in\" === g.move ? 0 : 1) - (\"in\" === c.move ? 0 : 1) : g.value - c.value;\n              });\n              var q = 0;\n              var B = u;\n              e.forEach(function (g) {\n                q += \"in\" === g.move ? 1 : -1;\n                1 === q && \"in\" === g.move && (B = g.value);\n                0 === q && E(B) && (c.push({\n                  from: B,\n                  to: g.value,\n                  len: g.value - B - (g.size || 0)\n                }), n += g.value - B - (g.size || 0));\n              });\n              h.breakArray = c;\n              E(u) && E(w) && E(k.min) && (h.unitLength = w - u - n + p, l(k, \"afterBreaks\"), k.staticScale ? k.transA = k.staticScale : h.unitLength && (k.transA *= (w - k.min + p) / h.unitLength), p && (k.minPixelPadding = k.transA * (k.minPointOffset || 0)), k.min = u, k.max = w);\n            }\n          });\n          x(q, !0) && k.chart.redraw();\n        };\n\n        return d;\n      }();\n\n      m.Additions = S;\n    })(b || (b = {}));\n\n    return b;\n  });\n  L(a, \"masters/modules/broken-axis.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Axis/BrokenAxis.js\"]], function (a, r) {\n    r.compose(a.Axis, a.Series);\n  });\n  L(a, \"Extensions/DataGrouping.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Tooltip.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l, D, E, x, b) {\n    var m = y.format,\n        d = D.prototype;\n    y = b.addEvent;\n    var z = b.arrayMax,\n        h = b.arrayMin,\n        K = b.correctFloat,\n        G = b.defined,\n        J = b.error,\n        C = b.extend,\n        q = b.isNumber,\n        R = b.merge,\n        S = b.pick;\n    \"\";\n    var F = t.approximations = {\n      sum: function (f) {\n        var e = f.length;\n        if (!e && f.hasNulls) var c = null;else if (e) for (c = 0; e--;) c += f[e];\n        return c;\n      },\n      average: function (f) {\n        var e = f.length;\n        f = F.sum(f);\n        q(f) && e && (f = K(f / e));\n        return f;\n      },\n      averages: function () {\n        var f = [];\n        [].forEach.call(arguments, function (e) {\n          f.push(F.average(e));\n        });\n        return \"undefined\" === typeof f[0] ? void 0 : f;\n      },\n      open: function (f) {\n        return f.length ? f[0] : f.hasNulls ? null : void 0;\n      },\n      high: function (f) {\n        return f.length ? z(f) : f.hasNulls ? null : void 0;\n      },\n      low: function (f) {\n        return f.length ? h(f) : f.hasNulls ? null : void 0;\n      },\n      close: function (f) {\n        return f.length ? f[f.length - 1] : f.hasNulls ? null : void 0;\n      },\n      hlc: function (f, e, c) {\n        f = F.high(f);\n        e = F.low(e);\n        c = F.close(c);\n        if (q(f) || q(e) || q(c)) return [f, e, c];\n      },\n      ohlc: function (f, e, c, p) {\n        f = F.open(f);\n        e = F.high(e);\n        c = F.low(c);\n        p = F.close(p);\n        if (q(f) || q(e) || q(c) || q(p)) return [f, e, c, p];\n      },\n      range: function (f, e) {\n        f = F.low(f);\n        e = F.high(e);\n        if (q(f) || q(e)) return [f, e];\n        if (null === f && null === e) return null;\n      }\n    };\n\n    b = function (f, e, c, p) {\n      var n = this,\n          g = n.data,\n          u = n.options && n.options.data,\n          w = [],\n          d = [],\n          b = [],\n          B = f.length,\n          H = !!e,\n          A = [],\n          h = n.pointArrayMap,\n          k = h && h.length,\n          m = [\"x\"].concat(h || [\"y\"]),\n          v = this.options.dataGrouping && this.options.dataGrouping.groupAll,\n          a = 0,\n          J = 0,\n          C;\n      p = \"function\" === typeof p ? p : F[p] ? F[p] : F[n.getDGApproximation && n.getDGApproximation() || \"average\"];\n      k ? h.forEach(function () {\n        A.push([]);\n      }) : A.push([]);\n      var K = k || 1;\n\n      for (C = 0; C <= B && !(f[C] >= c[0]); C++);\n\n      for (C; C <= B; C++) {\n        for (; \"undefined\" !== typeof c[a + 1] && f[C] >= c[a + 1] || C === B;) {\n          var z = c[a];\n          n.dataGroupInfo = {\n            start: v ? J : n.cropStart + J,\n            length: A[0].length\n          };\n          var l = p.apply(n, A);\n          n.pointClass && !G(n.dataGroupInfo.options) && (n.dataGroupInfo.options = R(n.pointClass.prototype.optionsToObject.call({\n            series: n\n          }, n.options.data[n.cropStart + J])), m.forEach(function (g) {\n            delete n.dataGroupInfo.options[g];\n          }));\n          \"undefined\" !== typeof l && (w.push(z), d.push(l), b.push(n.dataGroupInfo));\n          J = C;\n\n          for (z = 0; z < K; z++) A[z].length = 0, A[z].hasNulls = !1;\n\n          a += 1;\n          if (C === B) break;\n        }\n\n        if (C === B) break;\n\n        if (h) {\n          z = n.options.dataGrouping && n.options.dataGrouping.groupAll ? C : n.cropStart + C;\n          l = g && g[z] || n.pointClass.prototype.applyOptions.apply({\n            series: n\n          }, [u[z]]);\n          var x = void 0;\n\n          for (z = 0; z < k; z++) x = l[h[z]], q(x) ? A[z].push(x) : null === x && (A[z].hasNulls = !0);\n        } else z = H ? e[C] : null, q(z) ? A[0].push(z) : null === z && (A[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: w,\n        groupedYData: d,\n        groupMap: b\n      };\n    };\n\n    var O = {\n      approximations: F,\n      groupData: b\n    },\n        v = d.generatePoints,\n        P = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        k = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      arearange: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      },\n      hlc: {\n        groupPixelWidth: 5\n      },\n      heikinashi: {\n        groupPixelWidth: 10\n      }\n    },\n        I = t.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    d.getDGApproximation = function () {\n      return this.is(\"arearange\") ? \"range\" : this.is(\"ohlc\") ? \"ohlc\" : this.is(\"hlc\") ? \"hlc\" : this.is(\"column\") ? \"sum\" : \"average\";\n    };\n\n    d.groupData = b;\n\n    d.applyGrouping = function (f) {\n      var e = this.chart,\n          c = this.options.dataGrouping,\n          p = !1 !== this.allowDG && c && S(c.enabled, e.options.isStock),\n          n = this.visible || !e.options.chart.ignoreHiddenSeries,\n          g,\n          u = this.currentDataGrouping,\n          w = !1;\n      p && !this.requireSorting && (this.requireSorting = w = !0);\n      f = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !f) || !p;\n      w && (this.requireSorting = !1);\n\n      if (!f) {\n        this.destroyGroupedData();\n        p = c.groupAll ? this.xData : this.processedXData;\n        var b = c.groupAll ? this.yData : this.processedYData;\n        f = e.plotSizeX;\n        w = this.xAxis;\n        var h = w.options.ordinal,\n            B = this.groupPixelWidth;\n\n        if (B && p && p.length) {\n          this.isDirty = g = !0;\n          this.points = null;\n          var k = w.getExtremes();\n          var A = k.min;\n          k = k.max;\n          h = h && w.ordinal && w.ordinal.getGroupIntervalFactor(A, k, this) || 1;\n          f = w.getTimeTicks(r.Additions.prototype.normalizeTimeTickInterval(B * (k - A) / f * h, c.units || I), Math.min(A, p[0]), Math.max(k, p[p.length - 1]), w.options.startOfWeek, p, this.closestPointRange);\n          B = d.groupData.apply(this, [p, b, f, c.approximation]);\n          p = B.groupedXData;\n          b = B.groupedYData;\n          h = 0;\n          c && c.smoothed && p.length && (c.firstAnchor = \"firstPoint\", c.anchor = \"middle\", c.lastAnchor = \"lastPoint\", J(32, !1, e, {\n            \"dataGrouping.smoothed\": \"use dataGrouping.anchor\"\n          }));\n          e = p;\n          var m = this.options.dataGrouping;\n          A = this.currentDataGrouping && this.currentDataGrouping.gapSize;\n\n          if (m && this.xData && A && this.groupMap) {\n            var v = e.length - 1;\n            var a = m.anchor;\n            var C = S(m.firstAnchor, a);\n            m = S(m.lastAnchor, a);\n\n            if (a && \"start\" !== a) {\n              var z = A * {\n                middle: .5,\n                end: 1\n              }[a];\n\n              for (a = e.length - 1; a-- && 0 < a;) e[a] += z;\n            }\n\n            if (C && \"start\" !== C && this.xData[0] >= e[0]) {\n              a = this.groupMap[0].start;\n              z = this.groupMap[0].length;\n              var K = void 0;\n              q(a) && q(z) && (K = a + (z - 1));\n              e[0] = {\n                middle: e[0] + .5 * A,\n                end: e[0] + A,\n                firstPoint: this.xData[0],\n                lastPoint: K && this.xData[K]\n              }[C];\n            }\n\n            m && \"start\" !== m && A && e[v] >= k - A && (k = this.groupMap[this.groupMap.length - 1].start, e[v] = {\n              middle: e[v] + .5 * A,\n              end: e[v] + A,\n              firstPoint: k && this.xData[k],\n              lastPoint: this.xData[this.xData.length - 1]\n            }[m]);\n          }\n\n          for (k = 1; k < f.length; k++) f.info.segmentStarts && -1 !== f.info.segmentStarts.indexOf(k) || (h = Math.max(f[k] - f[k - 1], h));\n\n          k = f.info;\n          k.gapSize = h;\n          this.closestPointRange = f.info.totalRange;\n          this.groupMap = B.groupMap;\n\n          if (n) {\n            n = p;\n\n            if (G(n[0]) && q(w.min) && q(w.dataMin) && n[0] < w.min) {\n              if (!G(w.options.min) && w.min <= w.dataMin || w.min === w.dataMin) w.min = Math.min(n[0], w.min);\n              w.dataMin = Math.min(n[0], w.dataMin);\n            }\n\n            if (G(n[n.length - 1]) && q(w.max) && q(w.dataMax) && n[n.length - 1] > w.max) {\n              if (!G(w.options.max) && q(w.dataMax) && w.max >= w.dataMax || w.max === w.dataMax) w.max = Math.max(n[n.length - 1], w.max);\n              w.dataMax = Math.max(n[n.length - 1], w.dataMax);\n            }\n          }\n\n          c.groupAll && (this.allGroupedData = b, c = this.cropData(p, b, w.min, w.max, 1), p = c.xData, b = c.yData, this.cropStart = c.start);\n          this.processedXData = p;\n          this.processedYData = b;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = g;\n        this.currentDataGrouping = k;\n        this.preventGraphAnimation = (u && u.totalRange) !== (k && k.totalRange);\n      }\n    };\n\n    d.destroyGroupedData = function () {\n      this.groupedData && (this.groupedData.forEach(function (f, e) {\n        f && (this.groupedData[e] = f.destroy ? f.destroy() : null);\n      }, this), this.groupedData.length = 0);\n    };\n\n    d.generatePoints = function () {\n      v.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    a.prototype.applyGrouping = function (f) {\n      var e = this;\n      e.series.forEach(function (c) {\n        c.groupPixelWidth = void 0;\n        c.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth();\n        c.groupPixelWidth && (c.hasProcessed = !0);\n        c.applyGrouping(!!f.hasExtemesChanged);\n      });\n    };\n\n    a.prototype.getGroupPixelWidth = function () {\n      var f = this.series,\n          e = f.length,\n          c,\n          p = 0,\n          n = !1,\n          g;\n\n      for (c = e; c--;) (g = f[c].options.dataGrouping) && (p = Math.max(p, S(g.groupPixelWidth, P.groupPixelWidth)));\n\n      for (c = e; c--;) if (g = f[c].options.dataGrouping) if (e = (f[c].processedXData || f[c].data).length, f[c].groupPixelWidth || e > this.chart.plotSizeX / p || e && g.forced) n = !0;\n\n      return n ? p : 0;\n    };\n\n    a.prototype.setDataGrouping = function (f, e) {\n      var c;\n      e = S(e, !0);\n      f || (f = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof a) for (c = this.series.length; c--;) this.series[c].update({\n        dataGrouping: f\n      }, !1);else this.chart.options.series.forEach(function (c) {\n        c.dataGrouping = \"boolean\" === typeof f ? f : R(f, c.dataGrouping);\n      });\n      this.ordinal && (this.ordinal.slope = void 0);\n      e && this.chart.redraw();\n    };\n\n    y(a, \"postProcessData\", a.prototype.applyGrouping);\n    y(l, \"update\", function () {\n      if (this.dataGroup) return J(24, !1, this.series.chart), !1;\n    });\n    y(E, \"headerFormatter\", function (f) {\n      var e = this.chart,\n          c = e.time,\n          p = f.labelConfig,\n          n = p.series,\n          g = n.tooltipOptions,\n          u = n.options.dataGrouping,\n          w = g.xDateFormat,\n          d = n.xAxis,\n          b = g[f.isFooter ? \"footerFormat\" : \"headerFormat\"];\n\n      if (d && \"datetime\" === d.options.type && u && q(p.key)) {\n        var k = n.currentDataGrouping;\n        u = u.dateTimeLabelFormats || P.dateTimeLabelFormats;\n        if (k) {\n          if (g = u[k.unitName], 1 === k.count) w = g[0];else {\n            w = g[1];\n            var h = g[2];\n          }\n        } else !w && u && d.dateTime && (w = d.dateTime.getXDateFormat(p.x, g.dateTimeLabelFormats));\n        w = c.dateFormat(w, p.key);\n        h && (w += c.dateFormat(h, p.key + k.totalRange - 1));\n        n.chart.styledMode && (b = this.styledModeFormat(b));\n        f.text = m(b, {\n          point: C(p.point, {\n            key: w\n          }),\n          series: n\n        }, e);\n        f.preventDefault();\n      }\n    });\n    y(D, \"destroy\", d.destroyGroupedData);\n    y(D, \"afterSetOptions\", function (f) {\n      f = f.options;\n      var e = this.type,\n          c = this.chart.options.plotOptions,\n          p = x.defaultOptions.plotOptions[e].dataGrouping,\n          n = this.useCommonDataGrouping && P;\n\n      if (c && (k[e] || n)) {\n        p || (p = R(P, k[e]));\n        var g = this.chart.rangeSelector;\n        f.dataGrouping = R(n, p, c.series && c.series.dataGrouping, c[e].dataGrouping, this.userOptions.dataGrouping, !f.isInternal && g && q(g.selected) && g.buttonOptions[g.selected].dataGrouping);\n      }\n    });\n    y(a, \"afterSetScale\", function () {\n      this.series.forEach(function (f) {\n        f.hasProcessed = !1;\n      });\n    });\n    t.dataGrouping = O;\n    \"\";\n    return O;\n  });\n  L(a, \"Series/HLC/HLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var r = this && this.__extends || function () {\n      var a = function (t, l) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, l) {\n          a.__proto__ = l;\n        } || function (a, l) {\n          for (var x in l) l.hasOwnProperty(x) && (a[x] = l[x]);\n        };\n\n        return a(t, l);\n      };\n\n      return function (t, l) {\n        function D() {\n          this.constructor = t;\n        }\n\n        a(t, l);\n        t.prototype = null === l ? Object.create(l) : (D.prototype = l.prototype, new D());\n      };\n    }();\n\n    return function (a) {\n      function t() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.close = void 0;\n        l.high = void 0;\n        l.low = void 0;\n        l.options = void 0;\n        l.plotClose = void 0;\n        l.series = void 0;\n        return l;\n      }\n\n      r(t, a);\n      return t;\n    }(a.seriesTypes.column.prototype.pointClass);\n  });\n  L(a, \"Series/HLC/HLCSeries.js\", [a[\"Series/HLC/HLCPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, r, y) {\n    var t = this && this.__extends || function () {\n      var a = function (b, m) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var h in b) b.hasOwnProperty(h) && (d[h] = b[h]);\n        };\n\n        return a(b, m);\n      };\n\n      return function (b, m) {\n        function d() {\n          this.constructor = b;\n        }\n\n        a(b, m);\n        b.prototype = null === m ? Object.create(m) : (d.prototype = m.prototype, new d());\n      };\n    }(),\n        l = r.seriesTypes.column,\n        D = y.extend,\n        E = y.merge;\n\n    y = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      t(b, a);\n\n      b.prototype.extendStem = function (b, d, a) {\n        var h = b[0];\n        b = b[1];\n        \"number\" === typeof h[2] && (h[2] = Math.max(a + d, h[2]));\n        \"number\" === typeof b[2] && (b[2] = Math.min(a - d, b[2]));\n      };\n\n      b.prototype.getPointPath = function (b, d) {\n        d = d.strokeWidth();\n        var a = b.series,\n            h = d % 2 / 2,\n            m = Math.round(b.plotX) - h,\n            G = Math.round(b.shapeArgs.width / 2);\n        var J = [[\"M\", m, Math.round(b.yBottom)], [\"L\", m, Math.round(b.plotHigh)]];\n        null !== b.close && (b = Math.round(b.plotClose) + h, J.push([\"M\", m, b], [\"L\", m + G, b]), a.extendStem(J, d / 2, b));\n        return J;\n      };\n\n      b.prototype.drawSinglePoint = function (b) {\n        var d = b.series,\n            a = d.chart,\n            h = b.graphic,\n            m = !h;\n        \"undefined\" !== typeof b.plotY && (h || (b.graphic = h = a.renderer.path().add(d.group)), a.styledMode || h.attr(d.pointAttribs(b, b.selected && \"select\")), d = d.getPointPath(b, h), h[m ? \"attr\" : \"animate\"]({\n          d: d\n        }).addClass(b.getClassName(), !0));\n      };\n\n      b.prototype.drawPoints = function () {\n        this.points.forEach(this.drawSinglePoint);\n      };\n\n      b.prototype.init = function () {\n        a.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      b.prototype.pointAttribs = function (b, d) {\n        b = a.prototype.pointAttribs.call(this, b, d);\n        delete b.fill;\n        return b;\n      };\n\n      b.prototype.toYData = function (b) {\n        return [b.high, b.low, b.close];\n      };\n\n      b.prototype.translate = function () {\n        var b = this,\n            d = b.yAxis,\n            z = this.pointArrayMap && this.pointArrayMap.slice() || [],\n            h = z.map(function (b) {\n          return \"plot\" + (b.charAt(0).toUpperCase() + b.slice(1));\n        });\n        h.push(\"yBottom\");\n        z.push(\"low\");\n        a.prototype.translate.apply(b);\n        b.points.forEach(function (a) {\n          z.forEach(function (m, J) {\n            m = a[m];\n            null !== m && (b.dataModify && (m = b.dataModify.modifyValue(m)), a[h[J]] = d.toPixels(m, !0));\n          });\n          a.tooltipPos[1] = a.plotHigh + d.pos - b.chart.plotTop;\n        });\n      };\n\n      b.defaultOptions = E(l.defaultOptions, {\n        lineWidth: 1,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n        },\n        threshold: null,\n        states: {\n          hover: {\n            lineWidth: 3\n          }\n        },\n        stickyTracking: !0\n      });\n      return b;\n    }(l);\n\n    D(y.prototype, {\n      animate: null,\n      directTouch: !1,\n      pointArrayMap: [\"high\", \"low\", \"close\"],\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointValKey: \"close\"\n    });\n    y.prototype.pointClass = a;\n    r.registerSeriesType(\"hlc\", y);\n    \"\";\n    return y;\n  });\n  L(a, \"Series/OHLC/OHLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var r = this && this.__extends || function () {\n      var a = function (t, l) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, l) {\n          a.__proto__ = l;\n        } || function (a, l) {\n          for (var t in l) l.hasOwnProperty(t) && (a[t] = l[t]);\n        };\n\n        return a(t, l);\n      };\n\n      return function (t, l) {\n        function D() {\n          this.constructor = t;\n        }\n\n        a(t, l);\n        t.prototype = null === l ? Object.create(l) : (D.prototype = l.prototype, new D());\n      };\n    }();\n\n    return function (a) {\n      function t() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.open = void 0;\n        l.options = void 0;\n        l.plotOpen = void 0;\n        l.series = void 0;\n        return l;\n      }\n\n      r(t, a);\n\n      t.prototype.getClassName = function () {\n        return a.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      };\n\n      t.prototype.resolveUpColor = function () {\n        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);\n      };\n\n      t.prototype.resolveColor = function () {\n        a.prototype.resolveColor.call(this);\n        this.resolveUpColor();\n      };\n\n      t.prototype.getZone = function () {\n        var l = a.prototype.getZone.call(this);\n        this.resolveUpColor();\n        return l;\n      };\n\n      t.prototype.applyOptions = function () {\n        a.prototype.applyOptions.apply(this, arguments);\n        this.resolveColor && this.resolveColor();\n        return this;\n      };\n\n      return t;\n    }(a.seriesTypes.hlc.prototype.pointClass);\n  });\n  L(a, \"Series/OHLC/OHLCSeries.js\", [a[\"Series/OHLC/OHLCPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, r, y) {\n    var t = this && this.__extends || function () {\n      var b = function (d, a) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var a in d) d.hasOwnProperty(a) && (b[a] = d[a]);\n        };\n\n        return b(d, a);\n      };\n\n      return function (d, a) {\n        function h() {\n          this.constructor = d;\n        }\n\n        b(d, a);\n        d.prototype = null === a ? Object.create(a) : (h.prototype = a.prototype, new h());\n      };\n    }(),\n        l = r.series,\n        D = r.seriesTypes.hlc,\n        E = y.addEvent,\n        x = y.extend,\n        b = y.merge,\n        m = function (d) {\n      function a() {\n        var b = null !== d && d.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      t(a, d);\n\n      a.prototype.getPointPath = function (b, a) {\n        var h = d.prototype.getPointPath.call(this, b, a);\n        a = a.strokeWidth();\n        var m = a % 2 / 2,\n            C = Math.round(b.plotX) - m,\n            q = Math.round(b.shapeArgs.width / 2);\n        null !== b.open && (b = Math.round(b.plotOpen) + m, h.push([\"M\", C, b], [\"L\", C - q, b]), d.prototype.extendStem.call(this, h, a / 2, b));\n        return h;\n      };\n\n      a.prototype.pointAttribs = function (b, a) {\n        a = d.prototype.pointAttribs.call(this, b, a);\n        var h = this.options;\n        delete a.fill;\n        !b.options.color && h.upColor && b.open < b.close && (a.stroke = h.upColor);\n        return a;\n      };\n\n      a.prototype.toYData = function (b) {\n        return [b.open, b.high, b.low, b.close];\n      };\n\n      a.defaultOptions = b(D.defaultOptions, {\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n        }\n      });\n      return a;\n    }(D);\n\n    x(m.prototype, {\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"]\n    });\n    m.prototype.pointClass = a;\n    r.registerSeriesType(\"ohlc\", m);\n    E(l, \"init\", function (b) {\n      b = b.options;\n      b.useOhlcData && \"highcharts-navigator-series\" !== b.id && x(this, {\n        pointValKey: m.prototype.pointValKey,\n        pointArrayMap: m.prototype.pointArrayMap,\n        toYData: m.prototype.toYData\n      });\n    });\n    E(l, \"afterSetOptions\", function (b) {\n      b = b.options;\n      var a = b.dataGrouping;\n      a && b.useOhlcData && \"highcharts-navigator-series\" !== b.id && (a.approximation = \"ohlc\");\n    });\n    \"\";\n    return m;\n  });\n  L(a, \"Series/Candlestick/CandlestickSeries.js\", [a[\"Core/DefaultOptions.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, r, y) {\n    var t = this && this.__extends || function () {\n      var b = function (a, d) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) a.hasOwnProperty(d) && (b[d] = a[d]);\n        };\n\n        return b(a, d);\n      };\n\n      return function (a, d) {\n        function m() {\n          this.constructor = a;\n        }\n\n        b(a, d);\n        a.prototype = null === d ? Object.create(d) : (m.prototype = d.prototype, new m());\n      };\n    }(),\n        l = a.defaultOptions;\n\n    a = r.seriesTypes;\n    var D = a.column,\n        E = a.ohlc,\n        x = y.merge;\n\n    y = function (b) {\n      function a() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      t(a, b);\n\n      a.prototype.pointAttribs = function (b, a) {\n        var d = D.prototype.pointAttribs.call(this, b, a),\n            m = this.options,\n            l = b.open < b.close,\n            J = m.lineColor || this.color,\n            C = b.color || this.color;\n        d[\"stroke-width\"] = m.lineWidth;\n        d.fill = b.options.color || (l ? m.upColor || C : C);\n        d.stroke = b.options.lineColor || (l ? m.upLineColor || J : J);\n        a && (b = m.states[a], d.fill = b.color || d.fill, d.stroke = b.lineColor || d.stroke, d[\"stroke-width\"] = b.lineWidth || d[\"stroke-width\"]);\n        return d;\n      };\n\n      a.prototype.drawPoints = function () {\n        var b = this,\n            a = b.chart,\n            h = b.yAxis.reversed;\n        b.points.forEach(function (d) {\n          var m = d.graphic,\n              J = !m;\n\n          if (\"undefined\" !== typeof d.plotY) {\n            m || (d.graphic = m = a.renderer.path().add(b.group));\n            b.chart.styledMode || m.attr(b.pointAttribs(d, d.selected && \"select\")).shadow(b.options.shadow);\n            var C = m.strokeWidth() % 2 / 2;\n            var q = Math.round(d.plotX) - C;\n            var l = d.plotOpen;\n            var t = d.plotClose;\n            var F = Math.min(l, t);\n            l = Math.max(l, t);\n            var z = Math.round(d.shapeArgs.width / 2);\n            t = h ? l !== d.yBottom : Math.round(F) !== Math.round(d.plotHigh);\n            var v = h ? Math.round(F) !== Math.round(d.plotHigh) : l !== d.yBottom;\n            F = Math.round(F) + C;\n            l = Math.round(l) + C;\n            C = [];\n            C.push([\"M\", q - z, l], [\"L\", q - z, F], [\"L\", q + z, F], [\"L\", q + z, l], [\"Z\"], [\"M\", q, F], [\"L\", q, t ? Math.round(h ? d.yBottom : d.plotHigh) : F], [\"M\", q, l], [\"L\", q, v ? Math.round(h ? d.plotHigh : d.yBottom) : l]);\n            m[J ? \"attr\" : \"animate\"]({\n              d: C\n            }).addClass(d.getClassName(), !0);\n          }\n        });\n      };\n\n      a.defaultOptions = x(E.defaultOptions, l.plotOptions, {\n        states: {\n          hover: {\n            lineWidth: 2\n          }\n        },\n        tooltip: l.plotOptions.ohlc.tooltip,\n        threshold: null,\n        lineColor: \"#000000\",\n        lineWidth: 1,\n        upColor: \"#ffffff\",\n        stickyTracking: !0\n      });\n      return a;\n    }(E);\n\n    r.registerSeriesType(\"candlestick\", y);\n    \"\";\n    return y;\n  });\n  L(a, \"Series/Flags/FlagsPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, r) {\n    var y = this && this.__extends || function () {\n      var a = function (l, t) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var m in b) b.hasOwnProperty(m) && (a[m] = b[m]);\n        };\n\n        return a(l, t);\n      };\n\n      return function (l, t) {\n        function x() {\n          this.constructor = l;\n        }\n\n        a(l, t);\n        l.prototype = null === t ? Object.create(t) : (x.prototype = t.prototype, new x());\n      };\n    }(),\n        t = r.isNumber;\n\n    return function (a) {\n      function l() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.options = void 0;\n        l.series = void 0;\n        return l;\n      }\n\n      y(l, a);\n\n      l.prototype.isValid = function () {\n        return t(this.y) || \"undefined\" === typeof this.y;\n      };\n\n      l.prototype.hasNewShapeType = function () {\n        var a = this.options.shape || this.series.options.shape;\n        return this.graphic && a && a !== this.graphic.symbolKey;\n      };\n\n      return l;\n    }(a.seriesTypes.column.prototype.pointClass);\n  });\n  L(a, \"Series/OnSeriesComposition.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, r, y) {\n    var t = a.prototype,\n        l = r.prototype,\n        D = y.defined,\n        E = y.stableSort,\n        x;\n\n    (function (b) {\n      function a() {\n        return l.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      }\n\n      function d() {\n        t.translate.apply(this);\n        var b = this,\n            a = b.options,\n            d = b.chart,\n            m = b.points,\n            C = a.onSeries,\n            q = (C = C && d.get(C)) && C.options.step,\n            l = C && C.points,\n            z = d.inverted,\n            F = b.xAxis,\n            x = b.yAxis;\n        d = m.length - 1;\n        var v;\n        a = a.onKey || \"y\";\n        var r = l && l.length,\n            k = 0,\n            I;\n\n        if (C && C.visible && r) {\n          k = (C.pointXOffset || 0) + (C.barW || 0) / 2;\n          var f = C.currentDataGrouping;\n          var e = l[r - 1].x + (f ? f.totalRange : 0);\n          E(m, function (c, g) {\n            return c.x - g.x;\n          });\n\n          for (a = \"plot\" + a[0].toUpperCase() + a.substr(1); r-- && m[d];) {\n            var c = l[r];\n            f = m[d];\n            f.y = c.y;\n\n            if (c.x <= f.x && \"undefined\" !== typeof c[a]) {\n              if (f.x <= e && (f.plotY = c[a], c.x < f.x && !q && (I = l[r + 1]) && \"undefined\" !== typeof I[a])) {\n                var p = (f.x - c.x) / (I.x - c.x);\n                f.plotY += p * (I[a] - c[a]);\n                f.y += p * (I.y - c.y);\n              }\n\n              d--;\n              r++;\n              if (0 > d) break;\n            }\n          }\n        }\n\n        m.forEach(function (c, g) {\n          c.plotX += k;\n          if (\"undefined\" === typeof c.plotY || z) 0 <= c.plotX && c.plotX <= F.len ? z ? (c.plotY = F.translate(c.x, 0, 1, 0, 1), c.plotX = D(c.y) ? x.translate(c.y, 0, 0, 0, 1) : 0) : c.plotY = (F.opposite ? 0 : b.yAxis.len) + F.offset : c.shapeArgs = {};\n\n          if ((v = m[g - 1]) && v.plotX === c.plotX) {\n            \"undefined\" === typeof v.stackIndex && (v.stackIndex = 0);\n            var u = v.stackIndex + 1;\n          }\n\n          c.stackIndex = u;\n        });\n        this.onSeries = C;\n      }\n\n      var z = [];\n\n      b.compose = function (b) {\n        if (-1 === z.indexOf(b)) {\n          z.push(b);\n          var h = b.prototype;\n          h.getPlotBox = a;\n          h.translate = d;\n        }\n\n        return b;\n      };\n\n      b.getPlotBox = a;\n      b.translate = d;\n    })(x || (x = {}));\n\n    return x;\n  });\n  L(a, \"Series/Flags/FlagsSymbols.js\", [a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (a, r) {\n    function y(a) {\n      t[a + \"pin\"] = function (l, r, x, b, m) {\n        var d = m && m.anchorX;\n        m = m && m.anchorY;\n        \"circle\" === a && b > x && (l -= Math.round((b - x) / 2), x = b);\n        var z = t[a](l, r, x, b);\n\n        if (d && m) {\n          var h = d;\n          \"circle\" === a ? h = l + x / 2 : (l = z[0], x = z[1], \"M\" === l[0] && \"L\" === x[0] && (h = (l[1] + x[1]) / 2));\n          z.push([\"M\", h, r > m ? r : r + b], [\"L\", d, m]);\n          z = z.concat(t.circle(d - 1, m - 1, 2, 2));\n        }\n\n        return z;\n      };\n    }\n\n    var t = r.prototype.symbols;\n\n    t.flag = function (a, r, y, x, b) {\n      var m = b && b.anchorX || a;\n      b = b && b.anchorY || r;\n      var d = t.circle(m - 1, b - 1, 2, 2);\n      d.push([\"M\", m, b], [\"L\", a, r + x], [\"L\", a, r], [\"L\", a + y, r], [\"L\", a + y, r + x], [\"L\", a, r + x], [\"Z\"]);\n      return d;\n    };\n\n    y(\"circle\");\n    y(\"square\");\n    a = a.getRendererType();\n    a !== r && (a.prototype.symbols.circlepin = t.circlepin, a.prototype.symbols.flag = t.flag, a.prototype.symbols.squarepin = t.squarepin);\n    return t;\n  });\n  L(a, \"Series/Flags/FlagsSeries.js\", [a[\"Series/Flags/FlagsPoint.js\"], a[\"Core/Globals.js\"], a[\"Series/OnSeriesComposition.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l, D, E) {\n    var x = this && this.__extends || function () {\n      var b = function (a, d) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) a.hasOwnProperty(d) && (b[d] = a[d]);\n        };\n\n        return b(a, d);\n      };\n\n      return function (a, d) {\n        function q() {\n          this.constructor = a;\n        }\n\n        b(a, d);\n        a.prototype = null === d ? Object.create(d) : (q.prototype = d.prototype, new q());\n      };\n    }();\n\n    r = r.noop;\n    var b = t.distribute,\n        m = l.series,\n        d = l.seriesTypes.column,\n        z = E.addEvent,\n        h = E.defined;\n    t = E.extend;\n    var K = E.merge,\n        G = E.objectEach,\n        J = E.wrap;\n\n    E = function (a) {\n      function q() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      x(q, a);\n\n      q.prototype.animate = function (b) {\n        b && this.setClip();\n      };\n\n      q.prototype.drawPoints = function () {\n        var a = this.points,\n            d = this.chart,\n            q = d.renderer,\n            m = d.inverted,\n            v = this.options,\n            l = v.y,\n            k,\n            C = this.yAxis,\n            f = {},\n            e = [];\n\n        for (k = a.length; k--;) {\n          var c = a[k];\n          var p = (m ? c.plotY : c.plotX) > this.xAxis.len;\n          var n = c.plotX;\n          var g = c.stackIndex;\n          var u = c.options.shape || v.shape;\n          var w = c.plotY;\n          \"undefined\" !== typeof w && (w = c.plotY + l - (\"undefined\" !== typeof g && g * v.stackDistance));\n          c.anchorX = g ? void 0 : c.plotX;\n          var Q = g ? void 0 : c.plotY;\n          var N = \"flag\" !== u;\n          g = c.graphic;\n          \"undefined\" !== typeof w && 0 <= n && !p ? (g && c.hasNewShapeType() && (g = g.destroy()), g || (g = c.graphic = q.label(\"\", null, null, u, null, null, v.useHTML).addClass(\"highcharts-point\").add(this.markerGroup), c.graphic.div && (c.graphic.div.point = c), g.isNew = !0), g.attr({\n            align: N ? \"center\" : \"left\",\n            width: v.width,\n            height: v.height,\n            \"text-align\": v.textAlign\n          }), d.styledMode || g.attr(this.pointAttribs(c)).css(K(v.style, c.style)).shadow(v.shadow), 0 < n && (n -= g.strokeWidth() % 2), u = {\n            y: w,\n            anchorY: Q\n          }, v.allowOverlapX && (u.x = n, u.anchorX = c.anchorX), g.attr({\n            text: c.options.title || v.title || \"A\"\n          })[g.isNew ? \"attr\" : \"animate\"](u), v.allowOverlapX || (f[c.plotX] ? f[c.plotX].size = Math.max(f[c.plotX].size, g.width) : f[c.plotX] = {\n            align: N ? .5 : 0,\n            size: g.width,\n            target: n,\n            anchorX: n\n          }), c.tooltipPos = [n, w + C.pos - d.plotTop]) : g && (c.graphic = g.destroy());\n        }\n\n        if (!v.allowOverlapX) {\n          var B = 100;\n          G(f, function (g) {\n            g.plotX = g.anchorX;\n            e.push(g);\n            B = Math.max(g.size, B);\n          });\n          b(e, m ? C.len : this.xAxis.len, B);\n          a.forEach(function (g) {\n            var c = g.graphic && f[g.plotX];\n            c && (g.graphic[g.graphic.isNew ? \"attr\" : \"animate\"]({\n              x: c.pos + c.align * c.size,\n              anchorX: g.anchorX\n            }), h(c.pos) ? g.graphic.isNew = !1 : (g.graphic.attr({\n              x: -9999,\n              anchorX: -9999\n            }), g.graphic.isNew = !0));\n          });\n        }\n\n        v.useHTML && J(this.markerGroup, \"on\", function (g) {\n          return D.prototype.on.apply(g.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      };\n\n      q.prototype.drawTracker = function () {\n        var b = this.points;\n        a.prototype.drawTracker.call(this);\n        b.forEach(function (a) {\n          var d = a.graphic;\n          d && (a.unbindMouseOver && a.unbindMouseOver(), a.unbindMouseOver = z(d.element, \"mouseover\", function () {\n            0 < a.stackIndex && !a.raised && (a._y = d.y, d.attr({\n              y: a._y - 8\n            }), a.raised = !0);\n            b.forEach(function (b) {\n              b !== a && b.raised && b.graphic && (b.graphic.attr({\n                y: b._y\n              }), b.raised = !1);\n            });\n          }));\n        });\n      };\n\n      q.prototype.pointAttribs = function (b, a) {\n        var d = this.options,\n            q = b && b.color || this.color,\n            h = d.lineColor,\n            m = b && b.lineWidth;\n        b = b && b.fillColor || d.fillColor;\n        a && (b = d.states[a].fillColor, h = d.states[a].lineColor, m = d.states[a].lineWidth);\n        return {\n          fill: b || q,\n          stroke: h || q,\n          \"stroke-width\": m || d.lineWidth || 0\n        };\n      };\n\n      q.prototype.setClip = function () {\n        m.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);\n      };\n\n      q.defaultOptions = K(d.defaultOptions, {\n        pointRange: 0,\n        allowOverlapX: !1,\n        shape: \"flag\",\n        stackDistance: 12,\n        textAlign: \"center\",\n        tooltip: {\n          pointFormat: \"{point.text}\"\n        },\n        threshold: null,\n        y: -30,\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        states: {\n          hover: {\n            lineColor: \"#000000\",\n            fillColor: \"#ccd6eb\"\n          }\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\"\n        }\n      });\n      return q;\n    }(d);\n\n    y.compose(E);\n    t(E.prototype, {\n      allowDG: !1,\n      forceCrop: !0,\n      invertible: !1,\n      noSharedTooltip: !0,\n      pointClass: a,\n      sorted: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      buildKDTree: r,\n      init: m.prototype.init,\n      invertGroups: r\n    });\n    l.registerSeriesType(\"flags\", E);\n    \"\";\n    \"\";\n    return E;\n  });\n  L(a, \"Core/Axis/ScrollbarAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var r = a.addEvent,\n        y = a.defined,\n        t = a.pick;\n    return function () {\n      function a() {}\n\n      a.compose = function (l, E) {\n        if (-1 === a.composed.indexOf(l)) a.composed.push(l);else return l;\n\n        var x = function (b) {\n          var a = t(b.options && b.options.min, b.min),\n              d = t(b.options && b.options.max, b.max);\n          return {\n            axisMin: a,\n            axisMax: d,\n            scrollMin: y(b.dataMin) ? Math.min(a, b.min, b.dataMin, t(b.threshold, Infinity)) : a,\n            scrollMax: y(b.dataMax) ? Math.max(d, b.max, b.dataMax, t(b.threshold, -Infinity)) : d\n          };\n        };\n\n        r(l, \"afterInit\", function () {\n          var b = this;\n          b.options && b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new E(b.chart.renderer, b.options.scrollbar, b.chart), r(b.scrollbar, \"changed\", function (a) {\n            var d = x(b),\n                m = d.axisMax,\n                h = d.scrollMin,\n                l = d.scrollMax - h;\n            y(d.axisMin) && y(m) && (b.horiz && !b.reversed || !b.horiz && b.reversed ? (d = h + l * this.to, h += l * this.from) : (d = h + l * (1 - this.from), h += l * (1 - this.to)), this.shouldUpdateExtremes(a.DOMType) ? b.setExtremes(h, d, !0, \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType, a) : this.setRange(this.from, this.to));\n          }));\n        });\n        r(l, \"afterRender\", function () {\n          var b = x(this),\n              a = b.scrollMin,\n              d = b.scrollMax;\n          b = this.scrollbar;\n          var l = this.axisTitleMargin + (this.titleOffset || 0),\n              h = this.chart.scrollbarsOffsets,\n              t = this.options.margin || 0;\n          b && (this.horiz ? (this.opposite || (h[1] += l), b.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? t : 0), this.width, this.height), this.opposite || (h[1] += t), l = 1) : (this.opposite && (h[0] += l), b.position(b.options.opposite ? this.left + this.width + 2 + h[0] - (this.opposite ? 0 : t) : this.opposite ? 0 : t, this.top, this.width, this.height), this.opposite && (h[0] += t), l = 0), h[l] += b.size + b.options.margin, isNaN(a) || isNaN(d) || !y(this.min) || !y(this.max) || this.min === this.max ? b.setRange(0, 1) : (h = (this.min - a) / (d - a), a = (this.max - a) / (d - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? b.setRange(h, a) : b.setRange(1 - a, 1 - h)));\n        });\n        r(l, \"afterGetOffset\", function () {\n          var b = this.scrollbar && !this.scrollbar.options.opposite;\n          b = this.horiz ? 2 : b ? 3 : 1;\n          var a = this.scrollbar;\n          a && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[b] += a.size + a.options.margin);\n        });\n        return l;\n      };\n\n      a.composed = [];\n      return a;\n    }();\n  });\n  L(a, \"Core/ScrollbarDefaults.js\", [a[\"Core/Globals.js\"]], function (a) {\n    return {\n      height: a.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n  });\n  L(a, \"Core/Scrollbar.js\", [a[\"Core/DefaultOptions.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/ScrollbarAxis.js\"], a[\"Core/ScrollbarDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l) {\n    var D = a.defaultOptions,\n        E = l.addEvent,\n        x = l.correctFloat,\n        b = l.defined,\n        m = l.destroyObjectProperties,\n        d = l.fireEvent,\n        z = l.merge,\n        h = l.pick,\n        K = l.removeEvent;\n\n    a = function () {\n      function a(a, b, d) {\n        this._events = [];\n        this.chart = void 0;\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.renderer = this.options = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = void 0;\n        this.y = this.x = 0;\n        this.init(a, b, d);\n      }\n\n      a.compose = function (b) {\n        y.compose(b, a);\n      };\n\n      a.swapXY = function (a, b) {\n        b && a.forEach(function (a) {\n          for (var b = a.length, d, q = 0; q < b; q += 2) d = a[q + 1], \"number\" === typeof d && (a[q + 1] = a[q + 2], a[q + 2] = d);\n        });\n        return a;\n      };\n\n      a.prototype.addEvents = function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            b = this.scrollbarButtons,\n            d = this.scrollbarGroup.element,\n            h = this.track.element,\n            l = this.mouseDownHandler.bind(this),\n            m = this.mouseMoveHandler.bind(this),\n            t = this.mouseUpHandler.bind(this);\n        a = [[b[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [b[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [h, \"click\", this.trackClick.bind(this)], [d, \"mousedown\", l], [d.ownerDocument, \"mousemove\", m], [d.ownerDocument, \"mouseup\", t]];\n        r.hasTouch && a.push([d, \"touchstart\", l], [d.ownerDocument, \"touchmove\", m], [d.ownerDocument, \"touchend\", t]);\n        a.forEach(function (a) {\n          E.apply(null, a);\n        });\n        this._events = a;\n      };\n\n      a.prototype.buttonToMaxClick = function (a) {\n        var b = (this.to - this.from) * h(this.options.step, .2);\n        this.updatePosition(this.from + b, this.to + b);\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.buttonToMinClick = function (a) {\n        var b = x(this.to - this.from) * h(this.options.step, .2);\n        this.updatePosition(x(this.from - b), x(this.to - b));\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.cursorToScrollbarPosition = function (a) {\n        var b = this.options;\n        b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)\n        };\n      };\n\n      a.prototype.destroy = function () {\n        var a = this,\n            b = a.chart.scroller;\n        a.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (b) {\n          a[b] && a[b].destroy && (a[b] = a[b].destroy());\n        });\n        b && a === b.scrollbar && (b.scrollbar = null, m(b.scrollbarButtons));\n      };\n\n      a.prototype.drawScrollbarButton = function (b) {\n        var d = this.renderer,\n            q = this.scrollbarButtons,\n            h = this.options,\n            l = this.size,\n            m = d.g().add(this.group);\n        q.push(m);\n        m = d.rect().addClass(\"highcharts-scrollbar-button\").add(m);\n        this.chart.styledMode || m.attr({\n          stroke: h.buttonBorderColor,\n          \"stroke-width\": h.buttonBorderWidth,\n          fill: h.buttonBackgroundColor\n        });\n        m.attr(m.crisp({\n          x: -.5,\n          y: -.5,\n          width: l + 1,\n          height: l + 1,\n          r: h.buttonBorderRadius\n        }, m.strokeWidth()));\n        m = d.path(a.swapXY([[\"M\", l / 2 + (b ? -1 : 1), l / 2 - 3], [\"L\", l / 2 + (b ? -1 : 1), l / 2 + 3], [\"L\", l / 2 + (b ? 2 : -2), l / 2]], h.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(q[b]);\n        this.chart.styledMode || m.attr({\n          fill: h.buttonArrowColor\n        });\n      };\n\n      a.prototype.init = function (a, b, d) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = b;\n        this.options = z(t, D.scrollbar, b);\n        this.chart = d;\n        this.size = h(this.options.size, this.options.height);\n        b.enabled && (this.render(), this.addEvents());\n      };\n\n      a.prototype.mouseDownHandler = function (a) {\n        a = this.chart.pointer.normalize(a);\n        a = this.cursorToScrollbarPosition(a);\n        this.chartX = a.chartX;\n        this.chartY = a.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      a.prototype.mouseMoveHandler = function (a) {\n        var b = this.chart.pointer.normalize(a),\n            q = this.options.vertical ? \"chartY\" : \"chartX\",\n            h = this.initPositions || [];\n        !this.grabbedCenter || a.touches && 0 === a.touches[0][q] || (b = this.cursorToScrollbarPosition(b)[q], q = this[q], q = b - q, this.hasDragged = !0, this.updatePosition(h[0] + q, h[1] + q), this.hasDragged && d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        }));\n      };\n\n      a.prototype.mouseUpHandler = function (a) {\n        this.hasDragged && d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      a.prototype.position = function (a, b, d, h) {\n        var q = this.options.vertical,\n            l = this.rendered ? \"animate\" : \"attr\",\n            m = 0;\n        this.x = a;\n        this.y = b + this.trackBorderWidth;\n        this.width = d;\n        this.xOffset = this.height = h;\n        this.yOffset = m;\n        q ? (this.width = this.yOffset = d = m = this.size, this.xOffset = b = 0, this.barWidth = h - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = h = b = this.size, this.barWidth = d - 2 * h, this.y += this.options.margin);\n        this.group[l]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[l]({\n          width: d,\n          height: h\n        });\n        this.scrollbarButtons[1][l]({\n          translateX: q ? 0 : d - b,\n          translateY: q ? h - m : 0\n        });\n      };\n\n      a.prototype.removeEvents = function () {\n        this._events.forEach(function (a) {\n          K.apply(null, a);\n        });\n\n        this._events.length = 0;\n      };\n\n      a.prototype.render = function () {\n        var b = this.renderer,\n            d = this.options,\n            h = this.size,\n            l = this.chart.styledMode,\n            m = b.g(\"scrollbar\").attr({\n          zIndex: d.zIndex,\n          translateY: -99999\n        }).add();\n        this.group = m;\n        this.track = b.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: d.trackBorderRadius || 0,\n          height: h,\n          width: h\n        }).add(m);\n        l || this.track.attr({\n          fill: d.trackBackgroundColor,\n          stroke: d.trackBorderColor,\n          \"stroke-width\": d.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = b.g().add(m);\n        this.scrollbar = b.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: h,\n          width: h,\n          r: d.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = b.path(a.swapXY([[\"M\", -3, h / 4], [\"L\", -3, 2 * h / 3], [\"M\", 0, h / 4], [\"L\", 0, 2 * h / 3], [\"M\", 3, h / 4], [\"L\", 3, 2 * h / 3]], d.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        l || (this.scrollbar.attr({\n          fill: d.barBackgroundColor,\n          stroke: d.barBorderColor,\n          \"stroke-width\": d.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: d.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      a.prototype.setRange = function (a, d) {\n        var h = this.options,\n            l = h.vertical,\n            m = h.minWidth,\n            t = this.barWidth,\n            r = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (b(t)) {\n          var v = t * Math.min(d, 1);\n          a = Math.max(a, 0);\n          var z = Math.ceil(t * a);\n          this.calculatedWidth = v = x(v - z);\n          v < m && (z = (t - m + v) * a, v = m);\n          m = Math.floor(z + this.xOffset + this.yOffset);\n          t = v / 2 - .5;\n          this.from = a;\n          this.to = d;\n          l ? (this.scrollbarGroup[r]({\n            translateY: m\n          }), this.scrollbar[r]({\n            height: v\n          }), this.scrollbarRifles[r]({\n            translateY: t\n          }), this.scrollbarTop = m, this.scrollbarLeft = 0) : (this.scrollbarGroup[r]({\n            translateX: m\n          }), this.scrollbar[r]({\n            width: v\n          }), this.scrollbarRifles[r]({\n            translateX: t\n          }), this.scrollbarLeft = m, this.scrollbarTop = 0);\n          12 >= v ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);\n          !1 === h.showFull && (0 >= a && 1 <= d ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      a.prototype.shouldUpdateExtremes = function (a) {\n        return h(this.options.liveRedraw, r.svg && !r.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === a || \"touchend\" === a || !b(a);\n      };\n\n      a.prototype.trackClick = function (a) {\n        var b = this.chart.pointer.normalize(a),\n            h = this.to - this.from,\n            m = this.y + this.scrollbarTop,\n            l = this.x + this.scrollbarLeft;\n        this.options.vertical && b.chartY > m || !this.options.vertical && b.chartX > l ? this.updatePosition(this.from + h, this.to + h) : this.updatePosition(this.from - h, this.to - h);\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.update = function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, z(!0, this.options, a), this.chart);\n      };\n\n      a.prototype.updatePosition = function (a, b) {\n        1 < b && (a = x(1 - x(b - a)), b = 1);\n        0 > a && (b = x(b - a), a = 0);\n        this.from = a;\n        this.to = b;\n      };\n\n      a.defaultOptions = t;\n      return a;\n    }();\n\n    D.scrollbar = z(!0, a.defaultOptions, D.scrollbar);\n    return a;\n  });\n  L(a, \"Core/Axis/NavigatorAxis.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, r) {\n    var y = a.isTouchDevice,\n        t = r.addEvent,\n        l = r.correctFloat,\n        D = r.defined,\n        E = r.isNumber,\n        x = r.pick,\n        b = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      a.prototype.toFixedRange = function (a, b, h, m) {\n        var d = this.axis,\n            t = d.chart;\n        t = t && t.fixedRange;\n        var r = (d.pointRange || 0) / 2;\n        a = x(h, d.translate(a, !0, !d.horiz));\n        b = x(m, d.translate(b, !0, !d.horiz));\n        d = t && (b - a) / t;\n        D(h) || (a = l(a + r));\n        D(m) || (b = l(b - r));\n        .7 < d && 1.3 > d && (m ? a = b - t : b = a + t);\n        E(a) && E(b) || (a = b = void 0);\n        return {\n          min: a,\n          max: b\n        };\n      };\n\n      return a;\n    }();\n\n    return function () {\n      function a() {}\n\n      a.compose = function (a) {\n        a.keepProps.push(\"navigatorAxis\");\n        t(a, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new b(this));\n        });\n        t(a, \"zoom\", function (a) {\n          var b = this.chart.options,\n              d = b.navigator,\n              l = this.navigatorAxis,\n              m = b.chart.pinchType,\n              t = b.rangeSelector;\n          b = b.chart.zoomType;\n          this.isXAxis && (d && d.enabled || t && t.enabled) && (\"y\" === b ? a.zoomed = !1 : (!y && \"xy\" === b || y && \"xy\" === m) && this.options.range && (d = l.previousZoom, D(a.newMin) ? l.previousZoom = [this.min, this.max] : d && (a.newMin = d[0], a.newMax = d[1], l.previousZoom = void 0)));\n          \"undefined\" !== typeof a.zoomed && a.preventDefault();\n        });\n      };\n\n      a.AdditionsClass = b;\n      return a;\n    }();\n  });\n  L(a, \"Core/Navigator.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxis.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Scrollbar.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l, D, E, x, b, m, d) {\n    y = y.parse;\n\n    var z = t.hasTouch,\n        h = t.isTouchDevice,\n        K = D.defaultOptions,\n        G = d.addEvent,\n        J = d.clamp,\n        C = d.correctFloat,\n        q = d.defined,\n        L = d.destroyObjectProperties,\n        O = d.erase,\n        F = d.extend,\n        M = d.find,\n        v = d.isArray,\n        P = d.isNumber,\n        k = d.merge,\n        I = d.pick,\n        f = d.removeEvent,\n        e = d.splat,\n        c = function (a) {\n      for (var g = [], c = 1; c < arguments.length; c++) g[c - 1] = arguments[c];\n\n      g = [].filter.call(g, P);\n      if (g.length) return Math[a].apply(0, g);\n    };\n\n    D = \"undefined\" === typeof m.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    F(K, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: y(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: D,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: \"firstPoint\",\n            anchor: \"middle\",\n            lastAnchor: \"lastPoint\",\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    E.getRendererType().prototype.symbols[\"navigator-handle\"] = function (a, g, c, b, e) {\n      a = (e && e.width || 0) / 2;\n      g = Math.round(a / 3) + .5;\n      e = e && e.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, e + .5], [\"L\", -a - 1, e + .5], [\"L\", -a - 1, .5], [\"M\", -g, 4], [\"L\", -g, e - 3], [\"M\", g - 1, 4], [\"L\", g - 1, e - 3]];\n    };\n\n    var p = function () {\n      function b(g) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(g);\n      }\n\n      b.prototype.drawHandle = function (g, a, c, b) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[a][b](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(g, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(g, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      };\n\n      b.prototype.drawOutline = function (g, a, c, b) {\n        var e = this.navigatorOptions.maskInside,\n            u = this.outline.strokeWidth(),\n            d = u / 2,\n            w = u % 2 / 2;\n        u = this.outlineHeight;\n        var n = this.scrollbarHeight || 0,\n            p = this.size,\n            f = this.left - n,\n            k = this.top;\n        c ? (f -= d, c = k + a + w, a = k + g + w, w = [[\"M\", f + u, k - n - w], [\"L\", f + u, c], [\"L\", f, c], [\"L\", f, a], [\"L\", f + u, a], [\"L\", f + u, k + p + n]], e && w.push([\"M\", f + u, c - d], [\"L\", f + u, a + d])) : (g += f + n - w, a += f + n - w, k += d, w = [[\"M\", f, k], [\"L\", g, k], [\"L\", g, k + u], [\"L\", a, k + u], [\"L\", a, k], [\"L\", f + p + 2 * n, k]], e && w.push([\"M\", g - d, k], [\"L\", a + d, k]));\n        this.outline[b]({\n          d: w\n        });\n      };\n\n      b.prototype.drawMasks = function (a, c, b, e) {\n        var g = this.left,\n            u = this.top,\n            d = this.height;\n\n        if (b) {\n          var w = [g, g, g];\n          var n = [u, u + a, u + c];\n          var p = [d, d, d];\n          var f = [a, c - a, this.size - c];\n        } else w = [g, g + a, g + c], n = [u, u, u], p = [a, c - a, this.size - c], f = [d, d, d];\n\n        this.shades.forEach(function (a, g) {\n          a[e]({\n            x: w[g],\n            y: n[g],\n            width: p[g],\n            height: f[g]\n          });\n        });\n      };\n\n      b.prototype.renderElements = function () {\n        var a = this,\n            c = a.navigatorOptions,\n            b = c.maskInside,\n            e = a.chart,\n            d = e.renderer,\n            n,\n            p = {\n          cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = n = d.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!b, b, !b].forEach(function (g, b) {\n          var u = d.rect().addClass(\"highcharts-navigator-mask\" + (1 === b ? \"-inside\" : \"-outside\")).add(n);\n          e.styledMode || (u.attr({\n            fill: g ? c.maskFill : \"rgba(0,0,0,0)\"\n          }), 1 === b && u.css(p));\n          a.shades[b] = u;\n        });\n        a.outline = d.path().addClass(\"highcharts-navigator-outline\").add(n);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": c.outlineWidth,\n          stroke: c.outlineColor\n        });\n        c.handles.enabled && [0, 1].forEach(function (g) {\n          c.handles.inverted = e.inverted;\n          a.handles[g] = d.symbol(c.handles.symbols[g], -c.handles.width / 2 - 1, 0, c.handles.width, c.handles.height, c.handles);\n          a.handles[g].attr({\n            zIndex: 7 - g\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][g]).add(n);\n\n          if (!e.styledMode) {\n            var b = c.handles;\n            a.handles[g].attr({\n              fill: b.backgroundColor,\n              stroke: b.borderColor,\n              \"stroke-width\": b.lineWidth\n            }).css(p);\n          }\n        });\n      };\n\n      b.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        k(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      b.prototype.render = function (a, c, b, e) {\n        var g = this.chart,\n            u = this.scrollbarHeight,\n            d,\n            n = this.xAxis,\n            p = n.pointRange || 0;\n        var w = n.navigatorAxis.fake ? g.xAxis[0] : n;\n        var f = this.navigatorEnabled,\n            k,\n            h = this.rendered;\n        var l = g.inverted;\n        var m = g.xAxis[0].minRange,\n            v = g.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || q(b)) {\n          a = C(a - p / 2);\n          c = C(c + p / 2);\n          if (!P(a) || !P(c)) if (h) b = 0, e = I(n.width, w.width);else return;\n          this.left = I(n.left, g.plotLeft + u + (l ? g.plotWidth : 0));\n          this.size = k = d = I(n.len, (l ? g.plotHeight : g.plotWidth) - 2 * u);\n          g = l ? u : d + 2 * u;\n          b = I(b, n.toPixels(a, !0));\n          e = I(e, n.toPixels(c, !0));\n          P(b) && Infinity !== Math.abs(b) || (b = 0, e = g);\n          a = n.toValue(b, !0);\n          c = n.toValue(e, !0);\n          var Q = Math.abs(C(c - a));\n          Q < m ? this.grabbedLeft ? b = n.toPixels(c - m - p, !0) : this.grabbedRight && (e = n.toPixels(a + m + p, !0)) : q(v) && C(Q - p) > v && (this.grabbedLeft ? b = n.toPixels(c - v - p, !0) : this.grabbedRight && (e = n.toPixels(a + v + p, !0)));\n          this.zoomedMax = J(Math.max(b, e), 0, k);\n          this.zoomedMin = J(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(b, e), 0, k);\n          this.range = this.zoomedMax - this.zoomedMin;\n          k = Math.round(this.zoomedMax);\n          b = Math.round(this.zoomedMin);\n          f && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), h = h && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(b, k, l, h), this.drawOutline(b, k, l, h), this.navigatorOptions.handles.enabled && (this.drawHandle(b, 0, l, h), this.drawHandle(k, 1, l, h)));\n          this.scrollbar && (l ? (l = this.top - u, w = this.left - u + (f || !w.opposite ? 0 : (w.titleOffset || 0) + w.axisTitleMargin), u = d + 2 * u) : (l = this.top + (f ? this.height : -u), w = this.left - u), this.scrollbar.position(w, l, g, u), this.scrollbar.setRange(this.zoomedMin / (d || 1), this.zoomedMax / (d || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      b.prototype.addMouseEvents = function () {\n        var a = this,\n            c = a.chart,\n            b = c.container,\n            e = [],\n            d,\n            n;\n\n        a.mouseMoveHandler = d = function (c) {\n          a.onMouseMove(c);\n        };\n\n        a.mouseUpHandler = n = function (c) {\n          a.onMouseUp(c);\n        };\n\n        e = a.getPartsEvents(\"mousedown\");\n        e.push(G(c.renderTo, \"mousemove\", d), G(b.ownerDocument, \"mouseup\", n));\n        z && (e.push(G(c.renderTo, \"touchmove\", d), G(b.ownerDocument, \"touchend\", n)), e.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = e;\n        a.series && a.series[0] && e.push(G(a.series[0].xAxis, \"foundExtremes\", function () {\n          c.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      b.prototype.getPartsEvents = function (a) {\n        var c = this,\n            g = [];\n        [\"shades\", \"handles\"].forEach(function (b) {\n          c[b].forEach(function (e, u) {\n            g.push(G(e.element, a, function (a) {\n              c[b + \"Mousedown\"](a, u);\n            }));\n          });\n        });\n        return g;\n      };\n\n      b.prototype.shadesMousedown = function (a, c) {\n        a = this.chart.pointer.normalize(a);\n        var b = this.chart,\n            g = this.xAxis,\n            e = this.zoomedMin,\n            u = this.left,\n            d = this.size,\n            n = this.range,\n            p = a.chartX;\n        b.inverted && (p = a.chartY, u = this.top);\n        if (1 === c) this.grabbedCenter = p, this.fixedWidth = n, this.dragOffset = p - e;else {\n          a = p - u - n / 2;\n          if (0 === c) a = Math.max(0, a);else if (2 === c && a + n >= d) if (a = d - n, this.reversedExtremes) {\n            a -= n;\n            var f = this.getUnionExtremes().dataMin;\n          } else var k = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = n, c = g.navigatorAxis.toFixedRange(a, a + n, f, k), q(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      b.prototype.handlesMousedown = function (a, c) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var b = a.xAxis[0],\n            g = this.reversedExtremes;\n        0 === c ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = g ? b.min : b.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = g ? b.max : b.min);\n        a.fixedRange = null;\n      };\n\n      b.prototype.onMouseMove = function (a) {\n        var c = this,\n            b = c.chart,\n            g = c.left,\n            e = c.navigatorSize,\n            d = c.range,\n            n = c.dragOffset,\n            p = b.inverted;\n        a.touches && 0 === a.touches[0].pageX || (a = b.pointer.normalize(a), b = a.chartX, p && (g = c.top, b = a.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, b - g, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, b - g)) : c.grabbedCenter && (c.hasDragged = !0, b < n ? b = n : b > e + n - d && (b = e + n - d), c.render(0, 0, b - n, b - n + d)), c.hasDragged && c.scrollbar && I(c.scrollbar.options.liveRedraw, t.svg && !h && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {\n          c.onMouseUp(a);\n        }, 0)));\n      };\n\n      b.prototype.onMouseUp = function (a) {\n        var c = this.chart,\n            b = this.xAxis,\n            g = this.scrollbar,\n            e = a.DOMEvent || a,\n            d = c.inverted,\n            n = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!g || !g.hasDragged) || \"scrollbar\" === a.trigger) {\n          g = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var p = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var f = this.fixedExtreme;\n          this.zoomedMax === this.size && (f = this.reversedExtremes ? g.dataMin : g.dataMax);\n          0 === this.zoomedMin && (p = this.reversedExtremes ? g.dataMax : g.dataMin);\n          b = b.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, p, f);\n          q(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: e\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && P(this.zoomedMin) && P(this.zoomedMax) && (c = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(c, a, d, n), this.outline && this.drawOutline(c, a, d, n), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(c, 0, d, n), this.drawHandle(a, 1, d, n)));\n      };\n\n      b.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      b.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          f(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && f(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      b.prototype.init = function (b) {\n        var g = b.options,\n            e = g.navigator,\n            d = e.enabled,\n            n = g.scrollbar,\n            p = n.enabled;\n        g = d ? e.height : 0;\n        var f = p ? n.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = b;\n        this.setBaseSeries();\n        this.height = g;\n        this.scrollbarHeight = f;\n        this.scrollbarEnabled = p;\n        this.navigatorEnabled = d;\n        this.navigatorOptions = e;\n        this.scrollbarOptions = n;\n        this.outlineHeight = g + f;\n        this.opposite = I(e.opposite, !(d || !b.inverted));\n        var h = this;\n        d = h.baseSeries;\n        n = b.xAxis.length;\n        p = b.yAxis.length;\n        var m = d && d[0] && d[0].xAxis || b.xAxis[0] || {\n          options: {}\n        };\n        b.isDirtyBox = !0;\n        h.navigatorEnabled ? (h.xAxis = new a(b, k({\n          breaks: m.options.breaks,\n          ordinal: m.options.ordinal\n        }, e.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: n,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, b.inverted ? {\n          offsets: [f, 0, -f, 0],\n          width: g\n        } : {\n          offsets: [0, -f, 0, f],\n          height: g\n        })), h.yAxis = new a(b, k(e.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: p,\n          isInternal: !0,\n          reversed: I(e.yAxis && e.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, b.inverted ? {\n          width: g\n        } : {\n          height: g\n        })), d || e.series.data ? h.updateNavigatorSeries(!1) : 0 === b.series.length && (h.unbindRedraw = G(b, \"beforeRedraw\", function () {\n          0 < b.series.length && !h.series && (h.setBaseSeries(), h.unbindRedraw());\n        })), h.reversedExtremes = b.inverted && !h.xAxis.reversed || !b.inverted && h.xAxis.reversed, h.renderElements(), h.addMouseEvents()) : (h.xAxis = {\n          chart: b,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (a, g) {\n            var e = b.xAxis[0],\n                d = e.getExtremes(),\n                n = e.len - 2 * f,\n                p = c(\"min\", e.options.min, d.dataMin);\n            e = c(\"max\", e.options.max, d.dataMax) - p;\n            return g ? a * e / n + p : n * (a - p) / e;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, h.xAxis.navigatorAxis.axis = h.xAxis, h.xAxis.navigatorAxis.toFixedRange = l.AdditionsClass.prototype.toFixedRange.bind(h.xAxis.navigatorAxis));\n        b.options.scrollbar.enabled && (b.scrollbar = h.scrollbar = new x(b.renderer, k(b.options.scrollbar, {\n          margin: h.navigatorEnabled ? 0 : 10,\n          vertical: b.inverted\n        }), b), G(h.scrollbar, \"changed\", function (a) {\n          var c = h.size,\n              b = c * this.to;\n          c *= this.from;\n          h.hasDragged = h.scrollbar.hasDragged;\n          h.render(0, 0, c, b);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            h.onMouseUp(a);\n          });\n        }));\n        h.addBaseSeriesEvents();\n        h.addChartEvents();\n      };\n\n      b.prototype.getUnionExtremes = function (a) {\n        var b = this.chart.xAxis[0],\n            g = this.xAxis,\n            e = g.options,\n            d = b.options,\n            n;\n        a && null === b.dataMin || (n = {\n          dataMin: I(e && e.min, c(\"min\", d.min, b.dataMin, g.dataMin, g.min)),\n          dataMax: I(e && e.max, c(\"max\", d.max, b.dataMax, g.dataMax, g.max))\n        });\n        return n;\n      };\n\n      b.prototype.setBaseSeries = function (a, c) {\n        var b = this.chart,\n            g = this.baseSeries = [];\n        a = a || b.options && b.options.navigator.baseSeries || (b.series.length ? M(b.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (b.series || []).forEach(function (c, b) {\n          c.options.isInternal || !c.options.showInNavigator && (b !== a && c.options.id !== a || !1 === c.options.showInNavigator) || g.push(c);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, c);\n      };\n\n      b.prototype.updateNavigatorSeries = function (a, c) {\n        var b = this,\n            g = b.chart,\n            d = b.baseSeries,\n            n,\n            p,\n            u = b.navigatorOptions.series,\n            h,\n            l = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            m = b.series = (b.series || []).filter(function (a) {\n          var c = a.baseSeries;\n          return 0 > d.indexOf(c) ? (c && (f(c, \"updatedData\", b.updatedDataHandler), delete c.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        d && d.length && d.forEach(function (a) {\n          var f = a.navigatorSeries,\n              w = F({\n            color: a.color,\n            visible: a.visible\n          }, v(u) ? K.navigator.series : u);\n          f && !1 === b.navigatorOptions.adaptToUpdatedData || (l.name = \"Navigator \" + d.length, n = a.options || {}, h = n.navigatorOptions || {}, w.dataLabels = e(w.dataLabels), p = k(n, l, w, h), p.pointRange = I(w.pointRange, h.pointRange, K.plotOptions[p.type || \"line\"].pointRange), w = h.data || w.data, b.hasNavigatorData = b.hasNavigatorData || !!w, p.data = w || n.data && n.data.slice(0), f && f.options ? f.update(p, c) : (a.navigatorSeries = g.initSeries(p), a.navigatorSeries.baseSeries = a, m.push(a.navigatorSeries)));\n        });\n        if (u.data && (!d || !d.length) || v(u)) b.hasNavigatorData = !1, u = e(u), u.forEach(function (a, c) {\n          l.name = \"Navigator \" + (m.length + 1);\n          p = k(K.navigator.series, {\n            color: g.series[c] && !g.series[c].options.isInternal && g.series[c].color || g.options.colors[c] || g.options.colors[0]\n          }, l, a);\n          p.data = a.data;\n          p.data && (b.hasNavigatorData = !0, m.push(g.initSeries(p)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      b.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            c = a.baseSeries || [];\n        c[0] && c[0].xAxis && c[0].eventsToUnbind.push(G(c[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        c.forEach(function (c) {\n          c.eventsToUnbind.push(G(c, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          c.eventsToUnbind.push(G(c, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && c.xAxis && c.eventsToUnbind.push(G(c, \"updatedData\", this.updatedDataHandler));\n          c.eventsToUnbind.push(G(c, \"remove\", function () {\n            this.navigatorSeries && (O(a.series, this.navigatorSeries), q(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        }, this);\n      };\n\n      b.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, c) {\n          return Math.min(a, c.xData && c.xData.length ? c.xData[0] : a);\n        }, a);\n      };\n\n      b.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            c;\n        \"undefined\" !== typeof a.getExtremes && (!(c = this.getUnionExtremes(!0)) || c.dataMin === a.min && c.dataMax === a.max || (a.min = c.dataMin, a.max = c.dataMax));\n      };\n\n      b.prototype.modifyBaseAxisExtremes = function () {\n        var a = this.chart.navigator,\n            c = this.getExtremes(),\n            b = c.dataMin,\n            e = c.dataMax;\n        c = c.max - c.min;\n        var d = a.stickToMin,\n            n = a.stickToMax,\n            p = I(this.options.overscroll, 0),\n            f = a.series && a.series[0],\n            k = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (d) {\n            var h = b;\n            var l = h + c;\n          }\n\n          n && (l = e + p, d || (h = Math.max(b, l - c, a.getBaseSeriesMin(f && f.xData ? f.xData[0] : -Number.MAX_VALUE))));\n          k && (d || n) && P(h) && (this.min = this.userMin = h, this.max = this.userMax = l);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      };\n\n      b.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            c = this.navigatorSeries;\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = a.shouldStickToMin(this, a);\n        c && !a.hasNavigatorData && (c.options.pointStart = this.xData[0], c.setData(this.options.data, !1, null, !1));\n      };\n\n      b.prototype.shouldStickToMin = function (a, c) {\n        c = c.getBaseSeriesMin(a.xData[0]);\n        var b = a.xAxis;\n        a = b.max;\n        var g = b.min;\n        b = b.options.range;\n        return P(a) && P(g) ? b && 0 < a - c ? a - c < b : g <= c : !1;\n      };\n\n      b.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(G(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              c = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          c && a.render(c.min, c.max);\n        }), G(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              c = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (c = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[c] = (this[c] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      b.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (O(this.chart.xAxis, this.xAxis), O(this.chart.axes, this.xAxis));\n        this.yAxis && (O(this.chart.yAxis, this.yAxis), O(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          L(a);\n        }, this);\n      };\n\n      return b;\n    }();\n\n    t.Navigator || (t.Navigator = p, l.compose(a), G(r, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          c = a.navigator,\n          b = a.rangeSelector;\n      if ((c && c.enabled || b && b.enabled) && (!h && \"x\" === a.chart.zoomType || h && \"x\" === a.chart.pinchType)) return !1;\n    }), G(r, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new p(this);\n    }), G(r, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          c = this.navigator;\n\n      if (c) {\n        var b = a && a.options;\n        var e = c.xAxis;\n        var d = c.yAxis;\n        var p = c.scrollbarHeight;\n        this.inverted ? (c.left = c.opposite ? this.chartWidth - p - c.height : this.spacing[3] + p, c.top = this.plotTop + p) : (c.left = I(e.left, this.plotLeft + p), c.top = c.navigatorOptions.top || this.chartHeight - c.height - p - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (b && \"bottom\" === b.verticalAlign && \"proximate\" !== b.layout && b.enabled && !b.floating ? a.legendHeight + I(b.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        e && d && (this.inverted ? e.options.left = d.options.left = c.left : e.options.top = d.options.top = c.top, e.setAxisSize(), d.setAxisSize());\n      }\n    }), G(r, \"update\", function (a) {\n      var c = a.options.navigator || {},\n          b = a.options.scrollbar || {};\n      this.navigator || this.scroller || !c.enabled && !b.enabled || (k(!0, this.options.navigator, c), k(!0, this.options.scrollbar, b), delete a.options.navigator, delete a.options.scrollbar);\n    }), G(r, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new p(this), I(a.redraw, !0) && this.redraw(a.animation));\n    }), G(r, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), G(b, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), r.prototype.callbacks.push(function (a) {\n      var c = a.navigator;\n      c && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), c.render(a.min, a.max));\n    }));\n    t.Navigator = p;\n    return t.Navigator;\n  });\n  L(a, \"Extensions/RangeSelector.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Globals.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l, D) {\n    function E(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var c = \"aAdewbBmoyY\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      }),\n          b = \"HkIlMS\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      });\n      return c && b ? \"datetime-local\" : c ? \"date\" : b ? \"time\" : \"text\";\n    }\n\n    var x = t.defaultOptions,\n        b = D.addEvent,\n        m = D.createElement,\n        d = D.css,\n        z = D.defined,\n        h = D.destroyObjectProperties,\n        K = D.discardElement,\n        G = D.extend,\n        J = D.find,\n        C = D.fireEvent,\n        q = D.isNumber,\n        O = D.merge,\n        L = D.objectEach,\n        F = D.pad,\n        M = D.pick,\n        v = D.pInt,\n        P = D.splat;\n    G(x, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#335cad\",\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    G(x.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var k = function () {\n      function e(a) {\n        this.buttons = void 0;\n        this.buttonOptions = e.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n\n      e.prototype.clickButton = function (c, e) {\n        var d = this.chart,\n            g = this.buttonOptions[c],\n            p = d.xAxis[0],\n            f = d.scroller && d.scroller.getUnionExtremes() || p || {},\n            k = f.dataMin,\n            h = f.dataMax,\n            l = p && Math.round(Math.min(p.max, M(h, p.max))),\n            m = g.type;\n        f = g._range;\n        var v,\n            t = g.dataGrouping;\n\n        if (null !== k && null !== h) {\n          d.fixedRange = f;\n          this.setSelected(c);\n          t && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(p || {\n            chart: this.chart\n          }, t, !1), this.frozenStates = g.preserveDataGrouping);\n          if (\"month\" === m || \"year\" === m) {\n            if (p) {\n              m = {\n                range: g,\n                max: l,\n                chart: d,\n                dataMin: k,\n                dataMax: h\n              };\n              var r = p.minFromRange.call(m);\n              q(m.newMax) && (l = m.newMax);\n            } else f = g;\n          } else if (f) r = Math.max(l - f, k), l = Math.min(r + f, h);else if (\"ytd\" === m) {\n            if (p) \"undefined\" === typeof h && (k = Number.MAX_VALUE, h = Number.MIN_VALUE, d.series.forEach(function (a) {\n              a = a.xData;\n              k = Math.min(a[0], k);\n              h = Math.max(a[a.length - 1], h);\n            }), e = !1), l = this.getYTDExtremes(h, k, d.time.useUTC), r = v = l.min, l = l.max;else {\n              this.deferredYTDClick = c;\n              return;\n            }\n          } else \"all\" === m && p && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), r = k, l = h);\n          z(r) && (r += g._offsetMin);\n          z(l) && (l += g._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = c + 1);\n          if (p) p.setExtremes(r, l, M(e, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: g\n          });else {\n            var x = P(d.options.xAxis)[0];\n            var y = x.range;\n            x.range = f;\n            var I = x.min;\n            x.min = v;\n            b(d, \"load\", function () {\n              x.range = y;\n              x.min = I;\n            });\n          }\n          C(this, \"afterBtnClick\");\n        }\n      };\n\n      e.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      e.prototype.init = function (a) {\n        var c = this,\n            e = a.options.rangeSelector,\n            g = e.buttons || c.defaultButtons.slice(),\n            d = e.selected,\n            f = function () {\n          var a = c.minInput,\n              b = c.maxInput;\n          a && a.blur && C(a, \"blur\");\n          b && b.blur && C(b, \"blur\");\n        };\n\n        c.chart = a;\n        c.options = e;\n        c.buttons = [];\n        c.buttonOptions = g;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(b(a.container, \"mousedown\", f));\n        this.eventsToUnbind.push(b(a, \"resize\", f));\n        g.forEach(c.computeButtonRange);\n        \"undefined\" !== typeof d && g[d] && this.clickButton(d, !1);\n        this.eventsToUnbind.push(b(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && b(a.xAxis[0], \"setExtremes\", function (b) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== b.trigger && \"updatedData\" !== b.trigger && c.forcedDataGrouping && !c.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      e.prototype.updateButtonStates = function () {\n        var a = this,\n            b = this.chart,\n            e = this.dropdown,\n            g = b.xAxis[0],\n            d = Math.round(g.max - g.min),\n            f = !g.hasVisibleSeries,\n            k = b.scroller && b.scroller.getUnionExtremes() || g,\n            h = k.dataMin,\n            l = k.dataMax;\n        b = a.getYTDExtremes(l, h, b.time.useUTC);\n        var m = b.min,\n            v = b.max,\n            t = a.selected,\n            r = q(t),\n            x = a.options.allButtonsEnabled,\n            y = a.buttons;\n        a.buttonOptions.forEach(function (c, b) {\n          var p = c._range,\n              n = c.type,\n              k = c.count || 1,\n              u = y[b],\n              w = 0,\n              q = c._offsetMax - c._offsetMin;\n          c = b === t;\n          var B = p > l - h,\n              A = p < g.minRange,\n              H = !1,\n              z = !1;\n          p = p === d;\n          (\"month\" === n || \"year\" === n) && d + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[n] * k - q && d - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[n] * k + q ? p = !0 : \"ytd\" === n ? (p = v - m + q === d, H = !c) : \"all\" === n && (p = g.max - g.min >= l - h, z = !c && r && p);\n          n = !x && (B || A || z || f);\n          k = c && p || p && !r && !H || c && a.frozenStates;\n          n ? w = 3 : k && (r = !0, w = 2);\n          u.state !== w && (u.setState(w), e && (e.options[b + 1].disabled = n, 2 === w && (e.selectedIndex = b + 1)), 0 === w && t === b && a.setSelected());\n        });\n      };\n\n      e.prototype.computeButtonRange = function (a) {\n        var c = a.type,\n            b = a.count || 1,\n            e = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (e[c]) a._range = e[c] * b;else if (\"month\" === c || \"year\" === c) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[c] * b;\n        a._offsetMin = M(a.offsetMin, 0);\n        a._offsetMax = M(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      e.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var c = this.chart.options.rangeSelector,\n            b = this.chart.time;\n        return a ? (\"text\" === a.type && c.inputDateParser || this.defaultInputDateParser)(a.value, b.useUTC, b) : 0;\n      };\n\n      e.prototype.setInputValue = function (a, b) {\n        var c = this.options,\n            e = this.chart.time,\n            d = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (d) {\n          var f = d.getAttribute(\"data-hc-time\");\n          f = z(f) ? Number(f) : void 0;\n          z(b) && (z(f) && d.setAttribute(\"data-hc-time-previous\", f), d.setAttribute(\"data-hc-time\", b), f = b);\n          d.value = e.dateFormat(this.inputTypeFormats[d.type] || c.inputEditDateFormat, f);\n          a && a.attr({\n            text: e.dateFormat(c.inputDateFormat, f)\n          });\n        }\n      };\n\n      e.prototype.setInputExtremes = function (a, b, e) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var c = this.inputTypeFormats[a.type],\n              d = this.chart.time;\n          c && (b = d.dateFormat(c, b), a.min !== b && (a.min = b), e = d.dateFormat(c, e), a.max !== e && (a.max = e));\n        }\n      };\n\n      e.prototype.showInput = function (a) {\n        var c = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && c && this.inputGroup) {\n          var b = \"text\" === a.type,\n              e = this.inputGroup,\n              f = e.translateX;\n          e = e.translateY;\n          var k = this.options.inputBoxWidth;\n          d(a, {\n            width: b ? c.width + (k ? -2 : 20) + \"px\" : \"auto\",\n            height: b ? c.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          b && k ? d(a, {\n            left: f + c.x + \"px\",\n            top: e + \"px\"\n          }) : d(a, {\n            left: Math.min(Math.round(c.x + f - (a.offsetWidth - c.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: e - (a.offsetHeight - c.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      e.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && d(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      e.prototype.defaultInputDateParser = function (a, b, e) {\n        var c = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === c.indexOf(\"T\") && (c += \"T00:00\");\n        if (b) c += \"Z\";else {\n          var d;\n          if (d = y.isSafari) d = c, d = !(6 < d.length && (d.lastIndexOf(\"-\") === d.length - 6 || d.lastIndexOf(\"+\") === d.length - 6));\n          d && (d = new Date(c).getTimezoneOffset() / 60, c += 0 >= d ? \"+\" + F(-d) + \":00\" : \"-\" + F(d) + \":00\");\n        }\n        c = Date.parse(c);\n        q(c) || (a = a.split(\"-\"), c = Date.UTC(v(a[0]), v(a[1]) - 1, v(a[2])));\n        e && b && q(c) && (c += e.getTimezoneOffset(c));\n        return c;\n      };\n\n      e.prototype.drawInput = function (a) {\n        function b() {\n          var b = k.getInputValue(a),\n              e = c.xAxis[0],\n              d = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : e,\n              g = d.dataMin;\n          d = d.dataMax;\n          var f = k.maxInput,\n              p = k.minInput;\n          b !== Number(r.getAttribute(\"data-hc-time-previous\")) && q(b) && (r.setAttribute(\"data-hc-time-previous\", b), t && f && q(g) ? b > Number(f.getAttribute(\"data-hc-time\")) ? b = void 0 : b < g && (b = g) : p && q(d) && (b < Number(p.getAttribute(\"data-hc-time\")) ? b = void 0 : b > d && (b = d)), \"undefined\" !== typeof b && e.setExtremes(t ? b : e.min, t ? e.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var c = this.chart,\n            e = this.div,\n            f = this.inputGroup,\n            k = this,\n            h = c.renderer.style || {},\n            l = c.renderer,\n            v = c.options.rangeSelector,\n            t = \"min\" === a,\n            A = x.lang[t ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        A = l.label(A, 0).addClass(\"highcharts-range-label\").attr({\n          padding: A ? 2 : 0,\n          height: A ? v.inputBoxHeight : 0\n        }).add(f);\n        l = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: v.inputBoxWidth,\n          height: v.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          k.showInput(a);\n          k[a + \"Input\"].focus();\n        });\n        c.styledMode || l.attr({\n          stroke: v.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        l.add(f);\n        var r = m(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, e);\n        r.setAttribute(\"type\", E(v.inputDateFormat || \"%b %e, %Y\"));\n        c.styledMode || (A.css(O(h, v.labelStyle)), l.css(O({\n          color: \"#333333\"\n        }, h, v.inputStyle)), d(r, G({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: h.fontSize,\n          fontFamily: h.fontFamily,\n          top: \"-9999em\"\n        }, v.inputStyle)));\n\n        r.onfocus = function () {\n          k.showInput(a);\n        };\n\n        r.onblur = function () {\n          r === y.doc.activeElement && b();\n          k.hideInput(a);\n          k.setInputValue(a);\n          r.blur();\n        };\n\n        var z = !1;\n\n        r.onchange = function () {\n          z || (b(), k.hideInput(a), r.blur());\n        };\n\n        r.onkeypress = function (a) {\n          13 === a.keyCode && b();\n        };\n\n        r.onkeydown = function (a) {\n          z = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || b();\n        };\n\n        r.onkeyup = function () {\n          z = !1;\n        };\n\n        return {\n          dateBox: l,\n          input: r,\n          label: A\n        };\n      };\n\n      e.prototype.getPosition = function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      };\n\n      e.prototype.getYTDExtremes = function (a, b, e) {\n        var c = this.chart.time,\n            d = new c.Date(a),\n            f = c.get(\"FullYear\", d);\n        e = e ? c.Date.UTC(f, 0, 1) : +new c.Date(f, 0, 1);\n        b = Math.max(b, e);\n        d = d.getTime();\n        return {\n          max: Math.min(a || d, d),\n          min: b\n        };\n      };\n\n      e.prototype.render = function (a, b) {\n        var c = this.chart,\n            e = c.renderer,\n            d = c.container,\n            f = c.options,\n            p = f.rangeSelector,\n            k = M(f.chart.style && f.chart.style.zIndex, 0) + 1;\n        f = p.inputEnabled;\n\n        if (!1 !== p.enabled) {\n          this.rendered || (this.group = e.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = m(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: k\n          }), this.buttonOptions.length && this.renderButtons(), d.parentNode && d.parentNode.insertBefore(this.div, d), f && (this.inputGroup = e.g(\"input-group\").add(this.group), e = this.drawInput(\"min\"), this.minDateBox = e.dateBox, this.minLabel = e.label, this.minInput = e.input, e = this.drawInput(\"max\"), this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input));\n\n          if (f && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, z(a.dataMin) && z(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - c), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + c, a.dataMax)), this.inputGroup)) {\n            var h = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              if (a) {\n                var b = a.getBBox().width;\n                b && (a.attr({\n                  x: h\n                }), h += b + p.inputSpacing);\n              }\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      e.prototype.renderButtons = function () {\n        var a = this,\n            e = this.buttons,\n            d = this.options,\n            g = x.lang,\n            f = this.chart.renderer,\n            k = O(d.buttonTheme),\n            h = k && k.states,\n            l = k.width || 28;\n        delete k.width;\n        delete k.states;\n        this.buttonGroup = f.g(\"range-selector-buttons\").add(this.group);\n        var q = this.dropdown = m(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        b(q, \"touchstart\", function () {\n          q.style.fontSize = \"16px\";\n        });\n        [[y.isMS ? \"mouseover\" : \"mouseenter\"], [y.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (c) {\n          var d = c[0],\n              g = c[1];\n          b(q, d, function () {\n            var b = e[a.currentButtonIndex()];\n            b && C(b.element, g || d);\n          });\n        });\n        this.zoomText = f.label(g && g.rangeSelectorZoom || \"\", 0).attr({\n          padding: d.buttonTheme.padding,\n          height: d.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(d.labelStyle), k[\"stroke-width\"] = M(k[\"stroke-width\"], 0));\n        m(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, q);\n        this.buttonOptions.forEach(function (b, c) {\n          m(\"option\", {\n            textContent: b.title || b.text\n          }, void 0, q);\n          e[c] = f.button(b.text, 0, 0, function (e) {\n            var d = b.events && b.events.click,\n                g;\n            d && (g = d.call(b, e));\n            !1 !== g && a.clickButton(c);\n            a.isActive = !0;\n          }, k, h && h.hover, h && h.select, h && h.disabled).attr({\n            \"text-align\": \"center\",\n            width: l\n          }).add(a.buttonGroup);\n          b.title && e[c].attr(\"title\", b.title);\n        });\n      };\n\n      e.prototype.alignElements = function () {\n        var a = this,\n            b = this.buttonGroup,\n            e = this.buttons,\n            d = this.chart,\n            f = this.group,\n            k = this.inputGroup,\n            h = this.options,\n            l = this.zoomText,\n            m = d.options,\n            q = m.exporting && !1 !== m.exporting.enabled && m.navigation && m.navigation.buttonOptions;\n        m = h.buttonPosition;\n\n        var v = h.inputPosition,\n            t = h.verticalAlign,\n            r = function (b, c) {\n          return q && a.titleCollision(d) && \"top\" === t && \"right\" === c.align && c.y - b.getBBox().height - 12 < (q.y || 0) + (q.height || 0) + d.spacing[0] ? -40 : 0;\n        },\n            x = d.plotLeft;\n\n        if (f && m && v) {\n          var z = m.x - d.spacing[3];\n\n          if (b) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var y = 0;\n              l && (y += l.getBBox().width + 5);\n              e.forEach(function (a, b) {\n                y += a.width;\n                b !== e.length - 1 && (y += h.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = y;\n            }\n\n            x -= d.spacing[3];\n            this.updateButtonStates();\n            l = r(b, m);\n            this.alignButtonGroup(l);\n            f.placed = b.placed = d.hasLoaded;\n          }\n\n          b = 0;\n          k && (b = r(k, v), \"left\" === v.align ? z = x : \"right\" === v.align && (z = -Math.max(d.axisOffset[1], -b)), k.align({\n            y: v.y,\n            width: k.getBBox().width,\n            align: v.align,\n            x: v.x + z - 2\n          }, !0, d.spacingBox), k.placed = d.hasLoaded);\n          this.handleCollision(b);\n          f.align({\n            verticalAlign: t\n          }, !0, d.spacingBox);\n          k = f.alignAttr.translateY;\n          b = f.getBBox().height + 20;\n          r = 0;\n          \"bottom\" === t && (r = (r = d.legend && d.legend.options) && \"bottom\" === r.verticalAlign && r.enabled && !r.floating ? d.legend.legendHeight + M(r.margin, 10) : 0, b = b + r - 20, r = k - b - (h.floating ? 0 : h.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);\n          if (\"top\" === t) h.floating && (r = 0), d.titleOffset && d.titleOffset[0] && (r = d.titleOffset[0]), r += d.margin[0] - d.spacing[0] || 0;else if (\"middle\" === t) if (v.y === m.y) r = k;else if (v.y || m.y) r = 0 > v.y || 0 > m.y ? r - Math.min(v.y, m.y) : k - b;\n          f.translate(h.x, h.y + Math.floor(r));\n          m = this.minInput;\n          v = this.maxInput;\n          k = this.dropdown;\n          h.inputEnabled && m && v && (m.style.marginTop = f.translateY + \"px\", v.style.marginTop = f.translateY + \"px\");\n          k && (k.style.marginTop = f.translateY + \"px\");\n        }\n      };\n\n      e.prototype.alignButtonGroup = function (a, b) {\n        var c = this.chart,\n            e = this.buttonGroup,\n            d = this.options.buttonPosition,\n            f = c.plotLeft - c.spacing[3],\n            k = d.x - c.spacing[3];\n        \"right\" === d.align ? k += a - f : \"center\" === d.align && (k -= f / 2);\n        e && e.align({\n          y: d.y,\n          width: M(b, this.initialButtonGroupWidth),\n          align: d.align,\n          x: k\n        }, !0, c.spacingBox);\n      };\n\n      e.prototype.positionButtons = function () {\n        var a = this.buttons,\n            b = this.chart,\n            e = this.options,\n            d = this.zoomText,\n            f = b.hasLoaded ? \"animate\" : \"attr\",\n            k = e.buttonPosition,\n            h = b.plotLeft,\n            l = h;\n        d && \"hidden\" !== d.visibility && (d[f]({\n          x: M(h + k.x, h)\n        }), l += k.x + d.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, c) {\n          if (\"hidden\" !== a[c].visibility) a[c][f]({\n            x: l\n          }), l += a[c].width + e.buttonSpacing;else a[c][f]({\n            x: h\n          });\n        });\n      };\n\n      e.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            e = this.buttonGroup,\n            d = this.inputGroup,\n            f = this.options,\n            k = f.buttonPosition,\n            h = f.dropdown,\n            l = f.inputPosition;\n\n        f = function () {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var m = function (b) {\n          if (d && e) {\n            var c = d.alignAttr.translateX + d.alignOptions.x - a + d.getBBox().x + 2,\n                f = d.alignOptions.width,\n                g = e.alignAttr.translateX + e.getBBox().x;\n            return g + b > c && c + f > g && k.y < l.y + d.getBBox().height;\n          }\n\n          return !1;\n        },\n            v = function () {\n          d && e && d.attr({\n            translateX: d.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: d.alignAttr.translateY + e.getBBox().height + 10\n          });\n        };\n\n        if (e) {\n          if (\"always\" === h) {\n            this.collapseButtons(a);\n            m(f()) && v();\n            return;\n          }\n\n          \"never\" === h && this.expandButtons();\n        }\n\n        d && e ? l.align === k.align || m(this.initialButtonGroupWidth + 20) ? \"responsive\" === h ? (this.collapseButtons(a), m(f()) && v()) : v() : \"responsive\" === h && this.expandButtons() : e && \"responsive\" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      e.prototype.collapseButtons = function (a) {\n        var b = this.buttons,\n            c = this.buttonOptions,\n            e = this.chart,\n            d = this.dropdown,\n            f = this.options,\n            k = this.zoomText,\n            h = e.userOptions.rangeSelector && e.userOptions.rangeSelector.buttonTheme || {},\n            l = function (a) {\n          return {\n            text: a ? a + \" \\u25be\" : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: M(f.buttonTheme.paddingLeft, h.padding, 8),\n            paddingRight: M(f.buttonTheme.paddingRight, h.padding, 8)\n          };\n        };\n\n        k && k.hide();\n        var m = !1;\n        c.forEach(function (a, c) {\n          c = b[c];\n          2 !== c.state ? c.hide() : (c.show(), c.attr(l(a.text)), m = !0);\n        });\n        m || (d && (d.selectedIndex = 0), b[0].show(), b[0].attr(l(this.zoomText && this.zoomText.textStr)));\n        c = f.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== c && \"center\" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      e.prototype.expandButtons = function () {\n        var a = this.buttons,\n            b = this.buttonOptions,\n            e = this.options,\n            d = this.zoomText;\n        this.hideDropdown();\n        d && d.show();\n        b.forEach(function (b, c) {\n          c = a[c];\n          c.show();\n          c.attr({\n            text: b.text,\n            width: e.buttonTheme.width || 28,\n            paddingLeft: M(e.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: M(e.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > c.state && c.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      e.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      e.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            b = this.buttons,\n            e = this.chart,\n            f = this.dropdown;\n\n        if (a && f) {\n          var k = a.translateX;\n          a = a.translateY;\n          b = b[this.currentButtonIndex()].getBBox();\n          d(f, {\n            left: e.plotLeft + k + \"px\",\n            top: a + .5 + \"px\",\n            width: b.width + \"px\",\n            height: b.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      e.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (d(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      e.prototype.getHeight = function () {\n        var a = this.options,\n            b = this.group,\n            e = a.y,\n            d = a.buttonPosition.y,\n            f = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = b ? b.getBBox(!0).height + 13 + e : 0;\n        b = Math.min(f, d);\n        if (0 > f && 0 > d || 0 < f && 0 < d) a += Math.abs(b);\n        return a;\n      };\n\n      e.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      e.prototype.update = function (a) {\n        var b = this.chart;\n        O(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      e.prototype.destroy = function () {\n        var a = this,\n            b = a.minInput,\n            d = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), a.eventsToUnbind = void 0);\n        h(a.buttons);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        L(a, function (b, c) {\n          b && \"chart\" !== c && (b instanceof l ? b.destroy() : b instanceof window.HTMLElement && K(b));\n          b !== e.prototype[c] && (a[c] = null);\n        }, this);\n      };\n\n      return e;\n    }();\n\n    k.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    k.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    a.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          d = this.max,\n          f = this.chart.time,\n          g = function (a, c) {\n        var e = \"year\" === b ? \"FullYear\" : \"Month\",\n            d = new f.Date(a),\n            g = f.get(e, d);\n        f.set(e, d, g + c);\n        g === f.get(e, d) && f.set(\"Date\", d, 0);\n        return d.getTime() - a;\n      };\n\n      if (q(a)) {\n        var k = d - a;\n        var h = a;\n      } else k = d + g(d, -a.count), this.chart && (this.chart.fixedRange = d - k);\n\n      var l = M(this.dataMin, Number.MIN_VALUE);\n      q(k) || (k = l);\n      k <= l && (k = l, \"undefined\" === typeof h && (h = g(k, a.count)), this.newMax = Math.min(k + h, this.dataMax));\n      q(d) || (k = void 0);\n      return k;\n    };\n\n    if (!y.RangeSelector) {\n      var I = [],\n          f = function (a) {\n        function c() {\n          e && (d = a.xAxis[0].getExtremes(), f = a.legend, h = e && e.options.verticalAlign, q(d.min) && e.render(d.min, d.max), f.display && \"top\" === h && h === f.options.verticalAlign && (k = O(a.spacingBox), k.y = \"vertical\" === f.options.layout ? a.plotTop : k.y + e.getHeight(), f.group.placed = !1, f.align(k)));\n        }\n\n        var d,\n            e = a.rangeSelector,\n            f,\n            k,\n            h;\n        e && (J(I, function (b) {\n          return b[0] === a;\n        }) || I.push([a, [b(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          e && e.render(a.min, a.max);\n        }), b(a, \"redraw\", c)]]), c());\n      };\n\n      b(r, \"afterGetContainer\", function () {\n        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new k(this));\n      });\n      b(r, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (q(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      b(r, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var d = this.extraBottomMargin,\n            e = this.extraTopMargin;\n        b && b.enabled && !z(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new k(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (f(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n      });\n      b(r, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      b(r, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      r.prototype.callbacks.push(f);\n      b(r, \"destroy\", function () {\n        for (var a = 0; a < I.length; a++) {\n          var b = I[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            I.splice(a, 1);\n            break;\n          }\n        }\n      });\n      y.RangeSelector = k;\n    }\n\n    return k;\n  });\n  L(a, \"Core/Chart/StockChart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, r, y, t, l, D, E, x) {\n    function b(a, b) {\n      return \"xAxis\" === a ? {\n        minPadding: 0,\n        maxPadding: 0,\n        overscroll: 0,\n        ordinal: !0,\n        title: {\n          text: null\n        },\n        labels: {\n          overflow: \"justify\"\n        },\n        showLastLabel: !0\n      } : \"yAxis\" === a ? {\n        labels: {\n          y: -2\n        },\n        opposite: F(b.opposite, !0),\n        showLastLabel: !(!b.categories && \"category\" !== b.type),\n        title: {\n          text: null\n        }\n      } : {};\n    }\n\n    function m(a, b) {\n      if (\"xAxis\" === a) {\n        a = h();\n        var d = {\n          type: \"datetime\",\n          categories: void 0\n        };\n        F(b.navigator && b.navigator.enabled, a.navigator.enabled, !0) && (d.startOnTick = !1, d.endOnTick = !1);\n        return d;\n      }\n\n      return {};\n    }\n\n    var d = this && this.__extends || function () {\n      var a = function (b, d) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);\n        };\n\n        return a(b, d);\n      };\n\n      return function (b, d) {\n        function k() {\n          this.constructor = b;\n        }\n\n        a(b, d);\n        b.prototype = null === d ? Object.create(d) : (k.prototype = d.prototype, new k());\n      };\n    }(),\n        z = t.format,\n        h = l.getOptions;\n\n    a = x.addEvent;\n    var K = x.clamp,\n        G = x.defined,\n        J = x.extend,\n        C = x.find,\n        q = x.isNumber,\n        L = x.isString,\n        O = x.merge,\n        F = x.pick,\n        M = x.splat;\n\n    x = function (a) {\n      function l() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      d(l, a);\n\n      l.prototype.init = function (d, l) {\n        var f = h(),\n            e = d.xAxis,\n            c = d.yAxis,\n            k = F(d.navigator && d.navigator.enabled, f.navigator.enabled, !0);\n        d.xAxis = d.yAxis = void 0;\n        k = O({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: \"x\"\n            },\n            pinchType: \"x\"\n          },\n          navigator: {\n            enabled: k\n          },\n          scrollbar: {\n            enabled: F(f.scrollbar && f.scrollbar.enabled, !0)\n          },\n          rangeSelector: {\n            enabled: F(f.rangeSelector.enabled, !0)\n          },\n          title: {\n            text: null\n          },\n          tooltip: {\n            split: F(f.tooltip.split, !0),\n            crosshairs: !0\n          },\n          legend: {\n            enabled: !1\n          }\n        }, d, {\n          isStock: !0\n        });\n        d.xAxis = e;\n        d.yAxis = c;\n        k.xAxis = M(d.xAxis || {}).map(function (a, c) {\n          return O(b(\"xAxis\", a), f.xAxis, f.xAxis && f.xAxis[c], a, m(\"xAxis\", d));\n        });\n        k.yAxis = M(d.yAxis || {}).map(function (a, c) {\n          return O(b(\"yAxis\", a), f.yAxis, f.yAxis && f.yAxis[c], a);\n        });\n        a.prototype.init.call(this, k, l);\n      };\n\n      l.prototype.createAxis = function (d, h) {\n        h.axis = O(b(d, h.axis), h.axis, m(d, this.userOptions));\n        return a.prototype.createAxis.call(this, d, h);\n      };\n\n      return l;\n    }(y);\n\n    (function (a) {\n      a.stockChart = function (b, d, h) {\n        return new a(b, d, h);\n      };\n    })(x || (x = {}));\n\n    a(D, \"setOptions\", function (a) {\n      var b;\n      this.chart.options.isStock && (this.is(\"column\") || this.is(\"columnrange\") ? b = {\n        borderWidth: 0,\n        shadow: !1\n      } : this.is(\"scatter\") || this.is(\"sma\") || (b = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), b && (a.plotOptions[this.type] = O(a.plotOptions[this.type], b)));\n    });\n    a(r, \"autoLabelAlign\", function (a) {\n      var b = this.chart,\n          d = this.options;\n      b = b._labelPanes = b._labelPanes || {};\n      var h = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (d = d.top + \",\" + d.height, !b[d] && h.enabled && (15 === h.x && (h.x = 0), \"undefined\" === typeof h.align && (h.align = \"right\"), b[d] = this, a.align = \"right\", a.preventDefault()));\n    });\n    a(r, \"destroy\", function () {\n      var a = this.chart,\n          b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    a(r, \"getPlotLinePath\", function (a) {\n      function b(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = d.options[b];\n        return q(a) ? [f[b][a]] : L(a) ? [f.get(a)] : h.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var d = this,\n          h = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          f = d.chart,\n          e = f.renderer,\n          c = d.left,\n          l = d.top,\n          n,\n          g,\n          m,\n          t,\n          r = [],\n          v = [],\n          x = a.translatedValue,\n          z = a.value,\n          y = a.force;\n\n      if (f.options.isStock && !1 !== a.acrossPanes && \"xAxis\" === d.coll || \"yAxis\" === d.coll) {\n        a.preventDefault();\n        v = b(d.coll);\n        var D = d.isXAxis ? f.yAxis : f.xAxis;\n        D.forEach(function (a) {\n          if (G(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n            var b = a.isXAxis ? \"yAxis\" : \"xAxis\";\n            b = G(a.options[b]) ? f[b][a.options[b]] : f[b][0];\n            d === b && v.push(a);\n          }\n        });\n        var E = v.length ? [] : [d.isXAxis ? f.yAxis[0] : f.xAxis[0]];\n        v.forEach(function (a) {\n          -1 !== E.indexOf(a) || C(E, function (b) {\n            return b.pos === a.pos && b.len === a.len;\n          }) || E.push(a);\n        });\n        var J = F(x, d.translate(z, null, null, a.old));\n        q(J) && (d.horiz ? E.forEach(function (a) {\n          var b;\n          g = a.pos;\n          t = g + a.len;\n          n = m = Math.round(J + d.transB);\n          \"pass\" !== y && (n < c || n > c + d.width) && (y ? n = m = K(n, c, c + d.width) : b = !0);\n          b || r.push([\"M\", n, g], [\"L\", m, t]);\n        }) : E.forEach(function (a) {\n          var b;\n          n = a.pos;\n          m = n + a.len;\n          g = t = Math.round(l + d.height - J);\n          \"pass\" !== y && (g < l || g > l + d.height) && (y ? g = t = K(g, l, l + d.height) : b = !0);\n          b || r.push([\"M\", n, g], [\"L\", m, t]);\n        }));\n        a.path = 0 < r.length ? e.crispPolyLine(r, a.lineWidth || 1) : null;\n      }\n    });\n\n    E.prototype.crispPolyLine = function (a, b) {\n      for (var d = 0; d < a.length; d += 2) {\n        var h = a[d],\n            f = a[d + 1];\n        h[1] === f[1] && (h[1] = f[1] = Math.round(h[1]) - b % 2 / 2);\n        h[2] === f[2] && (h[2] = f[2] = Math.round(h[2]) + b % 2 / 2);\n      }\n\n      return a;\n    };\n\n    a(r, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    a(r, \"afterDrawCrosshair\", function (a) {\n      var b, d;\n\n      if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && q(this.min) && q(this.max)) {\n        var h = this.chart,\n            f = this.logarithmic,\n            e = this.crosshair.label,\n            c = this.horiz,\n            l = this.opposite,\n            n = this.left,\n            g = this.top,\n            m = this.crossLabel,\n            t = e.format,\n            r = \"\",\n            v = \"inside\" === this.options.tickPosition,\n            x = !1 !== this.crosshair.snap,\n            y = 0,\n            A = a.e || this.cross && this.cross.e;\n        a = a.point;\n        var C = this.min,\n            D = this.max;\n        f && (C = f.lin2log(C), D = f.lin2log(D));\n        f = c ? \"center\" : l ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        m || (m = this.crossLabel = h.renderer.label(\"\", 0, void 0, e.shape || \"callout\").addClass(\"highcharts-crosshair-label highcharts-color-\" + (a ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({\n          align: e.align || f,\n          padding: F(e.padding, 8),\n          r: F(e.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), h.styledMode || m.attr({\n          fill: e.backgroundColor || a && a.series && a.series.color || \"#666666\",\n          stroke: e.borderColor || \"\",\n          \"stroke-width\": e.borderWidth || 0\n        }).css(J({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, e.style || {})));\n        c ? (f = x ? (a.plotX || 0) + n : A.chartX, g += l ? 0 : this.height) : (f = l ? this.width + n : 0, g = x ? (a.plotY || 0) + g : A.chartY);\n        t || e.formatter || (this.dateTime && (r = \"%b %d, %Y\"), t = \"{value\" + (r ? \":\" + r : \"\") + \"}\");\n        r = x ? this.isXAxis ? a.x : a.y : this.toValue(c ? A.chartX : A.chartY);\n        x = a ? a.series.isPointInside(a) : q(r) && r > C && r < D;\n        A = \"\";\n        t ? A = z(t, {\n          value: r\n        }, h) : e.formatter && q(r) && (A = e.formatter.call(this, r));\n        m.attr({\n          text: A,\n          x: f,\n          y: g,\n          visibility: x ? \"visible\" : \"hidden\"\n        });\n        e = m.getBBox();\n        if (q(m.y)) if (c) {\n          if (v && !l || !v && l) g = m.y - e.height;\n        } else g = m.y - e.height / 2;\n        c ? (b = n - e.x, d = n + this.width - e.x) : (b = \"left\" === this.labelAlign ? n : 0, d = \"right\" === this.labelAlign ? n + this.width : h.chartWidth);\n        m.translateX < b && (y = b - m.translateX);\n        m.translateX + e.width >= d && (y = -(m.translateX + e.width - d));\n        m.attr({\n          x: f + y,\n          y: g,\n          anchorX: c ? f : this.opposite ? 0 : h.chartWidth,\n          anchorY: c ? this.opposite ? h.chartHeight : 0 : g + e.height / 2\n        });\n      }\n    });\n\n    D.prototype.forceCropping = function () {\n      var a = this.chart,\n          b = this.options.dataGrouping;\n      return !1 !== this.allowDG && b && F(b.enabled, a.options.isStock);\n    };\n\n    a(y, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (O(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n    return x;\n  });\n  L(a, \"masters/modules/stock.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Axis/OrdinalAxis.js\"], a[\"Series/DataModifyComposition.js\"], a[\"Core/Scrollbar.js\"], a[\"Core/Chart/StockChart.js\"]], function (a, r, y, t, l) {\n    a.Scrollbar = t;\n    a.StockChart = a.stockChart = l.stockChart;\n    t.compose(a.Axis);\n    r.compose(a.Axis, a.Series, a.Chart);\n    y.compose(a.Series, a.Axis, a.Point);\n  });\n}); //# sourceMappingURL=stock.js.map","map":null,"metadata":{},"sourceType":"script"}